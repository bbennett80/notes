Running flynt v.0.69
Running flynt in dry-run mode. No files will be changed.
--- /Users/braandon/openpilot/opendbc/can/dbc.py

+++ 

@@ -52,7 +52,7 @@

         dat = bo_regexp.match(l)
 
         if dat is None:
-          print("bad BO {0}".format(l))
+          print(f"bad BO {l}")
 
         name = dat.group(2)
         size = int(dat.group(3))
@@ -71,7 +71,7 @@

           go = 1
 
         if dat is None:
-          print("bad SG {0}".format(l))
+          print(f"bad SG {l}")
 
         sgname = dat.group(1)
         start_bit = int(dat.group(go + 2))
@@ -93,7 +93,7 @@

         dat = val_regexp.match(l)
 
         if dat is None:
-          print("bad VAL {0}".format(l))
+          print(f"bad VAL {l}")
 
         ids = int(dat.group(1), 0)  # could be hex
         sgname = dat.group(2)
@@ -104,7 +104,7 @@

 
         # convert strings to UPPER_CASE_WITH_UNDERSCORES
         defvals[1::2] = [d.strip().upper().replace(" ", "_") for d in defvals[1::2]]
-        defvals = '"' + "".join(str(i) for i in defvals) + '"'
+        defvals = f"\"{''.join(str(i) for i in defvals)}\""
 
         self.def_vals[ids].append((sgname, defvals))
 
--- /Users/braandon/openpilot/opendbc/can/process_dbc.py

+++ 

@@ -71,7 +71,7 @@

 
   # sanity checks on expected COUNTER and CHECKSUM rules, as packer and parser auto-compute those signals
   for address, msg_name, _, sigs in msgs:
-    dbc_msg_name = dbc_name + " " + msg_name
+    dbc_msg_name = f"{dbc_name} {msg_name}"
     for sig in sigs:
       if checksum_type is not None:
         # checksum rules
@@ -79,30 +79,30 @@

           if sig.size != checksum_size:
             sys.exit("%s: CHECKSUM is not %d bits long" % (dbc_msg_name, checksum_size))
           if sig.start_bit % 8 != checksum_start_bit:
-            sys.exit("%s: CHECKSUM starts at wrong bit" % dbc_msg_name)
+            sys.exit(f"{dbc_msg_name}: CHECKSUM starts at wrong bit")
           if little_endian != sig.is_little_endian:
-            sys.exit("%s: CHECKSUM has wrong endianness" % dbc_msg_name)
+            sys.exit(f"{dbc_msg_name}: CHECKSUM has wrong endianness")
         # counter rules
         if sig.name == "COUNTER":
           if counter_size is not None and sig.size != counter_size:
             sys.exit("%s: COUNTER is not %d bits long" % (dbc_msg_name, counter_size))
           if counter_start_bit is not None and sig.start_bit % 8 != counter_start_bit:
             print(counter_start_bit, sig.start_bit)
-            sys.exit("%s: COUNTER starts at wrong bit" % dbc_msg_name)
+            sys.exit(f"{dbc_msg_name}: COUNTER starts at wrong bit")
           if little_endian != sig.is_little_endian:
-            sys.exit("%s: COUNTER has wrong endianness" % dbc_msg_name)
+            sys.exit(f"{dbc_msg_name}: COUNTER has wrong endianness")
       # pedal rules
       if address in [0x200, 0x201]:
         if sig.name == "COUNTER_PEDAL" and sig.size != 4:
-          sys.exit("%s: PEDAL COUNTER is not 4 bits long" % dbc_msg_name)
+          sys.exit(f"{dbc_msg_name}: PEDAL COUNTER is not 4 bits long")
         if sig.name == "CHECKSUM_PEDAL" and sig.size != 8:
-          sys.exit("%s: PEDAL CHECKSUM is not 8 bits long" % dbc_msg_name)
+          sys.exit(f"{dbc_msg_name}: PEDAL CHECKSUM is not 8 bits long")
 
   # Fail on duplicate message names
   c = Counter([msg_name for address, msg_name, msg_size, sigs in msgs])
   for name, count in c.items():
     if count > 1:
-      sys.exit("%s: Duplicate message name in DBC file %s" % (dbc_name, name))
+      sys.exit(f"{dbc_name}: Duplicate message name in DBC file {name}")
 
   parser_code = template.render(dbc=can_dbc, checksum_type=checksum_type, msgs=msgs, def_vals=def_vals, len=len)
 
@@ -115,14 +115,14 @@

 
 def main():
   if len(sys.argv) != 3:
-    print("usage: %s dbc_directory output_filename" % (sys.argv[0],))
+    print(f"usage: {sys.argv[0]} dbc_directory output_filename")
     sys.exit(0)
 
   dbc_dir = sys.argv[1]
   out_fn = sys.argv[2]
 
   dbc_name = os.path.split(out_fn)[-1].replace('.cc', '')
-  in_fn = os.path.join(dbc_dir, dbc_name + '.dbc')
+  in_fn = os.path.join(dbc_dir, f"{dbc_name}.dbc")
 
   process(in_fn, out_fn)
 
--- /Users/braandon/openpilot/opendbc/can/tests/test_dbc_exceptions.py

+++ 

@@ -8,7 +8,7 @@

 class TestCanParserPackerExceptions(unittest.TestCase):
   def test_civic_exceptions(self):
     dbc_file = "honda_civic_touring_2016_can_generated"
-    dbc_invalid = dbc_file + "abcdef"
+    dbc_invalid = f"{dbc_file}abcdef"
     signals = [
       ("STEER_TORQUE", "STEERING_CONTROL", 0),
       ("STEER_TORQUE_REQUEST", "STEERING_CONTROL", 0),
--- /Users/braandon/openpilot/opendbc/generator/generator.py

+++ 

@@ -24,13 +24,13 @@

     dbc_file_out.write('CM_ "AUTOGENERATED FILE, DO NOT EDIT";\n')
 
     for include_filename in includes:
-      include_file_header = '\n\nCM_ "Imported file %s starts here";\n' % include_filename
+      include_file_header = f'\n\nCM_ "Imported file {include_filename} starts here";\n'
       dbc_file_out.write(include_file_header)
 
       include_file = read_dbc(src_dir, include_filename)
       dbc_file_out.write(include_file)
 
-    dbc_file_out.write('\nCM_ "%s starts here";\n' % filename)
+    dbc_file_out.write(f'\nCM_ "{filename} starts here";\n')
 
     core_dbc = include_pattern.sub('', dbc_file_in)
     dbc_file_out.write(core_dbc)
--- /Users/braandon/openpilot/opendbc/site_scons/site_tools/cython.py

+++ 

@@ -17,8 +17,8 @@

   matches += pyx_import_re.findall(contents)
 
   # Modules can be either .pxd or .pyx files
-  files = [m.replace('.', '/') + '.pxd' for m in matches]
-  files += [m.replace('.', '/') + '.pyx' for m in matches]
+  files = [f"{m.replace('.', '/')}.pxd" for m in matches]
+  files += [f"{m.replace('.', '/')}.pyx" for m in matches]
 
   # cdef extern from <file>
   files += cdef_import_re.findall(contents)
--- /Users/braandon/openpilot/tools/scripts/fetch_image_from_route.py

+++ 

@@ -2,7 +2,7 @@

 import sys
 
 if len(sys.argv) < 4:
-  print("%s <route> <segment> <frame number>" % sys.argv[0])
+  print(f"{sys.argv[0]} <route> <segment> <frame number>")
   print('example: ./fetch_image_from_route.py "02c45f73a2e5c6e9|2020-06-01--18-03-08" 3 500')
   exit(0)
 
@@ -17,8 +17,8 @@

 segment = int(sys.argv[2])
 frame = int(sys.argv[3])
 
-url = 'https://api.commadotai.com/v1/route/'+sys.argv[1]+"/files"
-r = requests.get(url, headers={"Authorization": "JWT "+jwt})
+url = f"https://api.commadotai.com/v1/route/{sys.argv[1]}/files"
+r = requests.get(url, headers={"Authorization": f"JWT {jwt}"})
 assert r.status_code == 200
 print("got api response")
 
@@ -31,8 +31,8 @@

   raise Exception("frame %d not found, got %d frames" % (frame, fr.frame_count))
 
 im = Image.fromarray(fr.get(frame, count=1, pix_fmt="rgb24")[0])
-fn = "uxxx_"+route.replace("|", "_")+"_%d_%d.png" % (segment, frame)
+fn = f"uxxx_{route.replace('|', '_')}{'_%d_%d.png' % (segment, frame)}"
 im.save(fn)
-print("saved %s" % fn)
+print(f"saved {fn}")
 
 
--- /Users/braandon/openpilot/tools/scripts/save_ubloxraw_stream.py

+++ 

@@ -52,7 +52,7 @@

           i += 1
     except StopIteration:
       print('All done')
-  print('Writed {} msgs'.format(i))
+  print(f'Writed {i} msgs')
 
 
 if __name__ == "__main__":
--- /Users/braandon/openpilot/tools/scripts/setup_ssh_keys.py

+++ 

@@ -7,7 +7,7 @@

 
 if __name__ == "__main__":
   if len(sys.argv) < 2:
-    print("%s <github username>" % sys.argv[0])
+    print(f"{sys.argv[0]} <github username>")
     exit(1)
 
   username = sys.argv[1]
--- /Users/braandon/openpilot/tools/lib/auth.py

+++ 

@@ -41,7 +41,7 @@

     'prompt': 'select_account',
   }
 
-  return (redirect_uri, 'https://accounts.google.com/o/oauth2/auth?' + urlencode(params))
+  return (redirect_uri, f"https://accounts.google.com/o/oauth2/auth?{urlencode(params)}")
 
 def login():
   redirect_uri, oauth_uri = auth_redirect_link()
--- /Users/braandon/openpilot/tools/lib/logreader.py

+++ 

@@ -26,7 +26,7 @@

   def _log_reader(self, i):
     if self._log_readers[i] is None and self._log_paths[i] is not None:
       log_path = self._log_paths[i]
-      print("LogReader:%s" % log_path)
+      print(f"LogReader:{log_path}")
       self._log_readers[i] = LogReader(log_path)
 
     return self._log_readers[i]
--- /Users/braandon/openpilot/tools/lib/url_file.py

+++ 

@@ -68,7 +68,7 @@

   def get_length(self):
     if self._length is not None:
       return self._length
-    file_length_path = os.path.join(CACHE_DIR, hash_256(self._url) + "_length")
+    file_length_path = os.path.join(CACHE_DIR, f"{hash_256(self._url)}_length")
     if os.path.exists(file_length_path) and not self._force_download:
       with open(file_length_path, "r") as file_length:
           content = file_length.read()
@@ -93,7 +93,7 @@

     while True:
       self._pos = position
       chunk_number = self._pos / CHUNK_SIZE
-      file_name = hash_256(self._url) + "_" + str(chunk_number)
+      file_name = f"{hash_256(self._url)}_{str(chunk_number)}"
       full_path = os.path.join(CACHE_DIR, str(file_name))
       data = None
       #  If we don't have a file, download it
@@ -156,7 +156,7 @@

     if self._debug:
       t2 = time.time()
       if t2 - t1 > 0.1:
-        print("get %s %r %.f slow" % (self._url, headers, t2 - t1))
+        print(f"get {self._url} {headers!r} {t2 - t1:.f} slow")
 
     response_code = c.getinfo(pycurl.RESPONSE_CODE)
     if response_code == 416:  # Requested Range Not Satisfiable
--- /Users/braandon/openpilot/tools/lib/route.py

+++ 

@@ -47,7 +47,7 @@

 
   def _get_segments_remote(self):
     api = CommaApi(get_token())
-    route_files = api.get('v1/route/' + self.route_name + '/files')
+    route_files = api.get(f"v1/route/{self.route_name}/files")
 
     segments = {}
     for url in chain.from_iterable(route_files.values()):
@@ -95,7 +95,7 @@

           if not seg_num.isdigit():
             continue
 
-          segment_name = '{}--{}'.format(self.route_name, seg_num)
+          segment_name = f'{self.route_name}--{seg_num}'
           for seg_f in os.listdir(os.path.join(fullpath, seg_num)):
             segment_files[segment_name].append((os.path.join(fullpath, seg_num, seg_f), seg_f))
 
@@ -125,7 +125,7 @@

       segments.append(RouteSegment(segment, log_path, qlog_path, camera_path, qcamera_path))
 
     if len(segments) == 0:
-      raise ValueError('Could not find segments for route {} in data directory {}'.format(self.route_name, data_dir))
+      raise ValueError(f'Could not find segments for route {self.route_name} in data directory {data_dir}')
     return sorted(segments, key=lambda seg: seg.canonical_name.segment_num)
 
 class RouteSegment(object):
--- /Users/braandon/openpilot/tools/lib/framereader.py

+++ 

@@ -50,7 +50,7 @@

   with FileReader(fn) as f:
     header = f.read(4)
   if len(header) == 0:
-    raise DataUnreadableError("%s is empty" % fn)
+    raise DataUnreadableError(f"{fn} is empty")
   elif header == b"\x00\xc0\x12\x00":
     return FrameType.raw
   elif header == b"\x00\x00\x00\x01":
@@ -90,7 +90,7 @@

     try:
       subprocess.check_call([vidindex, typ, fn, prefix_f.name, index_f.name])
     except subprocess.CalledProcessError:
-      raise DataUnreadableError("vidindex failed on file %s" % fn)
+      raise DataUnreadableError(f"vidindex failed on file {fn}")
     with open(index_f.name, "rb") as f:
       index = f.read()
     with open(prefix_f.name, "rb") as f:
@@ -308,7 +308,7 @@

     assert num+count <= self.frame_count
 
     if pix_fmt not in ("yuv420p", "rgb24"):
-      raise ValueError("Unsupported pixel format %r" % pix_fmt)
+      raise ValueError(f"Unsupported pixel format {pix_fmt!r}")
 
     app = []
     for i in range(num, num+count):
@@ -548,10 +548,10 @@

     assert self.frame_count is not None
 
     if num + count > self.frame_count:
-      raise ValueError("{} > {}".format(num + count, self.frame_count))
+      raise ValueError(f"{num + count} > {self.frame_count}")
 
     if pix_fmt not in ("yuv420p", "rgb24", "yuv444p"):
-      raise ValueError("Unsupported pixel format %r" % pix_fmt)
+      raise ValueError(f"Unsupported pixel format {pix_fmt!r}")
 
     ret = [self._get_one(num + i, pix_fmt) for i in range(count)]
 
--- /Users/braandon/openpilot/tools/lib/route_framereader.py

+++ 

@@ -22,7 +22,7 @@

       self[key] = frame_reader
       return frame_reader
     else:
-      raise KeyError("Segment index out of bounds: {}".format(key))
+      raise KeyError(f"Segment index out of bounds: {key}")
 
 
 class RouteFrameReader(object):
--- /Users/braandon/openpilot/tools/lib/api.py

+++ 

@@ -7,16 +7,16 @@

     self.session = requests.Session()
     self.session.headers['User-agent'] = 'OpenpilotTools'
     if token:
-      self.session.headers['Authorization'] = 'JWT ' + token
+      self.session.headers['Authorization'] = f"JWT {token}"
 
   def request(self, method, endpoint, **kwargs):
-    resp = self.session.request(method, API_HOST + '/' + endpoint, **kwargs)
+    resp = self.session.request(method, f"{API_HOST}/{endpoint}", **kwargs)
     resp_json = resp.json()
     if isinstance(resp_json, dict) and resp_json.get('error'):
       if resp.status_code in [401, 403]:
         raise UnauthorizedError('Unauthorized. Authenticate with tools/lib/auth.py')
 
-      e = APIError(str(resp.status_code) + ":" + resp_json.get('description', str(resp_json['error'])))
+      e = APIError(f"{str(resp.status_code)}:{resp_json.get('description', str(resp_json['error']))}")
       e.status_code = resp.status_code
       raise e
     return resp_json
--- /Users/braandon/openpilot/tools/replay/ui.py

+++ 

@@ -195,14 +195,14 @@

 
     lines = [
       info_font.render("ENABLED", True, GREEN if sm['controlsState'].enabled else BLACK),
-      info_font.render("SPEED: " + str(round(sm['carState'].vEgo, 1)) + " m/s", True, YELLOW),
-      info_font.render("LONG CONTROL STATE: " + str(sm['controlsState'].longControlState), True, YELLOW),
-      info_font.render("LONG MPC SOURCE: " + str(sm['longitudinalPlan'].longitudinalPlanSource), True, YELLOW),
+      info_font.render(f"SPEED: {str(round(sm['carState'].vEgo, 1))} m/s", True, YELLOW),
+      info_font.render(f"LONG CONTROL STATE: {str(sm['controlsState'].longControlState)}", True, YELLOW),
+      info_font.render(f"LONG MPC SOURCE: {str(sm['longitudinalPlan'].longitudinalPlanSource)}", True, YELLOW),
       None,
-      info_font.render("ANGLE OFFSET (AVG): " + str(round(sm['liveParameters'].angleOffsetAverageDeg, 2)) + " deg", True, YELLOW),
-      info_font.render("ANGLE OFFSET (INSTANT): " + str(round(sm['liveParameters'].angleOffsetDeg, 2)) + " deg", True, YELLOW),
-      info_font.render("STIFFNESS: " + str(round(sm['liveParameters'].stiffnessFactor * 100., 2)) + " %", True, YELLOW),
-      info_font.render("STEER RATIO: " + str(round(sm['liveParameters'].steerRatio, 2)), True, YELLOW)
+      info_font.render(f"ANGLE OFFSET (AVG): {str(round(sm['liveParameters'].angleOffsetAverageDeg, 2))} deg", True, YELLOW),
+      info_font.render(f"ANGLE OFFSET (INSTANT): {str(round(sm['liveParameters'].angleOffsetDeg, 2))} deg", True, YELLOW),
+      info_font.render(f"STIFFNESS: {str(round(sm['liveParameters'].stiffnessFactor * 100.0, 2))} %", True, YELLOW),
+      info_font.render(f"STEER RATIO: {str(round(sm['liveParameters'].steerRatio, 2))}", True, YELLOW)
     ]
 
     for i, line in enumerate(lines):
--- /Users/braandon/openpilot/tools/replay/unlogger.py

+++ 

@@ -282,7 +282,7 @@

             print("binding", typ)
             send_funcs[typ] = _get_address_send_func(address)
           except Exception as e:
-            print("couldn't replay {}: {}".format(typ, e))
+            print(f"couldn't replay {typ}: {e}")
             continue
         else:
           # Skip messages that we are not registered to publish.
@@ -346,7 +346,7 @@

 
   non_services = set(address_mapping) - set(service_list)
   if non_services:
-    print("WARNING: Unknown services {}".format(list(non_services)))
+    print(f"WARNING: Unknown services {list(non_services)}")
 
   return address_mapping
 
@@ -378,7 +378,7 @@

 
         q.send_pyobj(SeekAbsoluteTime(seek_time))
       except Exception as e:
-        print("Time not understood: {}".format(e))
+        print(f"Time not understood: {e}")
 
 def get_arg_parser():
   parser = argparse.ArgumentParser(
@@ -436,9 +436,9 @@

 def main(argv):
   args = get_arg_parser().parse_args(sys.argv[1:])
 
-  command_address = "ipc:///tmp/{}".format(uuid4())
-  forward_commands_address = "ipc:///tmp/{}".format(uuid4())
-  data_address = "ipc:///tmp/{}".format(uuid4())
+  command_address = f"ipc:///tmp/{uuid4()}"
+  forward_commands_address = f"ipc:///tmp/{uuid4()}"
+  data_address = f"ipc:///tmp/{uuid4()}"
 
   address_mapping = _get_address_mapping(args)
 
--- /Users/braandon/openpilot/tools/replay/lib/ui_helpers.py

+++ 

@@ -140,7 +140,7 @@

       plots.append(plot)
       idxs.append(name_to_arr_idx[item])
       plot_select.append(i)
-    axs[i].set_title(", ".join("%s (%s)" % (nm, cl)
+    axs[i].set_title(", ".join(f"{nm} ({cl})"
                                for (nm, cl) in zip(pl_list, plot_colors[i])), fontsize=10)
     axs[i].tick_params(axis="x", colors="white")
     axs[i].tick_params(axis="y", colors="white")
--- /Users/braandon/openpilot/tools/joystick/joystickd.py

+++ 

@@ -64,7 +64,7 @@

       dat.testJoystick.axes = [joystick.axes_values[a] for a in joystick.axes_values]
       dat.testJoystick.buttons = [joystick.cancel]
       joystick_sock.send(dat.to_bytes())
-      print('\n' + ', '.join([f'{name}: {round(v, 3)}' for name, v in joystick.axes_values.items()]))
+      print(f"\n{', '.join([f'{name}: {round(v, 3)}' for name, v in joystick.axes_values.items()])}")
 
 
 if __name__ == '__main__':
--- /Users/braandon/openpilot/tools/sim/lib/manual_ctrl.py

+++ 

@@ -10,7 +10,7 @@

 print('Available devices:')
 for fn in os.listdir('/dev/input'):
     if fn.startswith('js'):
-        print('  /dev/input/%s' % (fn))
+        print(f'  /dev/input/{fn}')
 
 # We'll store the states here.
 axis_states = {}
@@ -94,7 +94,7 @@

 def wheel_poll_thread(q: 'Queue[str]') -> NoReturn:
   # Open the joystick device.
   fn = '/dev/input/js0'
-  print('Opening %s...' % fn)
+  print(f'Opening {fn}...')
   jsdev = open(fn, 'rb')
 
   # Get the device name.
@@ -102,7 +102,7 @@

   buf = array.array('B', [0] * 64)
   ioctl(jsdev, 0x80006a13 + (0x10000 * len(buf)), buf)  # JSIOCGNAME(len)
   js_name = buf.tobytes().rstrip(b'\x00').decode('utf-8')
-  print('Device name: %s' % js_name)
+  print(f'Device name: {js_name}')
 
   # Get number of axes and buttons.
   buf = array.array('B', [0])
@@ -118,7 +118,7 @@

   ioctl(jsdev, 0x80406a32, buf)  # JSIOCGAXMAP
 
   for _axis in buf[:num_axes]:
-      axis_name = axis_names.get(_axis, 'unknown(0x%02x)' % _axis)
+      axis_name = axis_names.get(_axis, f'unknown(0x{_axis:02x})')
       axis_map.append(axis_name)
       axis_states[axis_name] = 0.0
 
@@ -127,7 +127,7 @@

   ioctl(jsdev, 0x80406a34, buf)  # JSIOCGBTNMAP
 
   for btn in buf[:num_buttons]:
-      btn_name = button_names.get(btn, 'unknown(0x%03x)' % btn)
+      btn_name = button_names.get(btn, f'unknown(0x{btn:03x})')
       button_map.append(btn_name)
       button_states[btn_name] = 0
 
@@ -153,19 +153,19 @@

         fvalue = value / 32767.0
         axis_states[axis] = fvalue
         normalized = (1 - fvalue) * 50
-        q.put("throttle_%f" % normalized)
+        q.put(f"throttle_{normalized:f}")
 
       elif axis == "rz":  # brake
         fvalue = value / 32767.0
         axis_states[axis] = fvalue
         normalized = (1 - fvalue) * 50
-        q.put("brake_%f" % normalized)
+        q.put(f"brake_{normalized:f}")
 
       elif axis == "x":  # steer angle
         fvalue = value / 32767.0
         axis_states[axis] = fvalue
         normalized = fvalue
-        q.put("steer_%f" % normalized)
+        q.put(f"steer_{normalized:f}")
 
     elif mtype & 0x01:  # buttons
       if value == 1: # press down
Skipping fstrings transform of file /Users/braandon/openpilot/pyextra/acados_template/acados_sim_solver.py due to unknown encoding: future_fstrings.
--- /Users/braandon/openpilot/pyextra/acados_template/generate_c_code_external_cost.py

+++ 

@@ -96,10 +96,10 @@

 
     cwd = os.getcwd()
     os.chdir(code_export_dir)
-    gen_dir = model.name + '_cost'
+    gen_dir = f"{model.name}_cost"
     if not os.path.exists(gen_dir):
         os.mkdir(gen_dir)
-    gen_dir_location = "./" + gen_dir
+    gen_dir_location = f"./{gen_dir}"
     os.chdir(gen_dir_location)
 
     ext_cost_fun.generate(fun_name, casadi_opts)
--- /Users/braandon/openpilot/pyextra/acados_template/generate_c_code_explicit_ode.py

+++ 

@@ -68,7 +68,7 @@

     Sp = symbol('Sp', nx, nu)
     lambdaX = symbol('lambdaX', nx, 1)
 
-    fun_name = model_name + '_expl_ode_fun'
+    fun_name = f"{model_name}_expl_ode_fun"
 
     ## Set up functions
     expl_ode_fun = Function(fun_name, [x, u, p], [f_expl])
@@ -76,13 +76,13 @@

     vdeX = jtimes(f_expl,x,Sx)
     vdeP = jacobian(f_expl,u) + jtimes(f_expl,x,Sp)
 
-    fun_name = model_name + '_expl_vde_forw'
+    fun_name = f"{model_name}_expl_vde_forw"
 
     expl_vde_forw = Function(fun_name, [x, Sx, Sp, u, p], [f_expl, vdeX, vdeP])
 
     adj = jtimes(f_expl, vertcat(x, u), lambdaX, True)
 
-    fun_name = model_name + '_expl_vde_adj'
+    fun_name = f"{model_name}_expl_vde_adj"
     expl_vde_adj = Function(fun_name, [x, lambdaX, u, p], [adj])
 
     if generate_hess:
@@ -93,7 +93,7 @@

             for i in range(j,nx+nu):
                 hess2 = vertcat(hess2, hess[i,j])
 
-        fun_name = model_name + '_expl_ode_hess'
+        fun_name = f"{model_name}_expl_ode_hess"
         expl_ode_hess = Function(fun_name, [x, Sx, Sp, lambdaX, u, p], [adj, hess2])
 
     ## generate C code
@@ -102,22 +102,22 @@

 
     cwd = os.getcwd()
     os.chdir(code_export_dir)
-    model_dir = model_name + '_model'
+    model_dir = f"{model_name}_model"
     if not os.path.exists(model_dir):
         os.mkdir(model_dir)
-    model_dir_location = './' + model_dir
+    model_dir_location = f"./{model_dir}"
     os.chdir(model_dir_location)
-    fun_name = model_name + '_expl_ode_fun'
+    fun_name = f"{model_name}_expl_ode_fun"
     expl_ode_fun.generate(fun_name, casadi_opts)
 
-    fun_name = model_name + '_expl_vde_forw'
+    fun_name = f"{model_name}_expl_vde_forw"
     expl_vde_forw.generate(fun_name, casadi_opts)
 
-    fun_name = model_name + '_expl_vde_adj'
+    fun_name = f"{model_name}_expl_vde_adj"
     expl_vde_adj.generate(fun_name, casadi_opts)
 
     if generate_hess:
-        fun_name = model_name + '_expl_ode_hess'
+        fun_name = f"{model_name}_expl_ode_hess"
         expl_ode_hess.generate(fun_name, casadi_opts)
     os.chdir(cwd)
 
--- /Users/braandon/openpilot/pyextra/acados_template/generate_c_code_gnsf.py

+++ 

@@ -51,10 +51,10 @@

 
     cwd = os.getcwd()
     os.chdir(code_export_dir)
-    model_dir = model_name + '_model'
+    model_dir = f"{model_name}_model"
     if not os.path.exists(model_dir):
         os.mkdir(model_dir)
-    model_dir_location = './' + model_dir
+    model_dir_location = f"./{model_dir}"
     os.chdir(model_dir_location)
 
     # obtain gnsf dimensions
@@ -89,21 +89,21 @@

     empty_var = symbol("gnsf_empty_var", 0, 0)
 
     ## generate C code
-    fun_name = model_name + '_gnsf_phi_fun'
+    fun_name = f"{model_name}_gnsf_phi_fun"
     phi_fun_ = Function(fun_name, [y, uhat, p], [phi_fun(y, uhat, p)])
     phi_fun_.generate(fun_name, casadi_opts)
 
-    fun_name = model_name + '_gnsf_phi_fun_jac_y'
+    fun_name = f"{model_name}_gnsf_phi_fun_jac_y"
     phi_fun_jac_y = model.phi_fun_jac_y
     phi_fun_jac_y_ = Function(fun_name, [y, uhat, p], phi_fun_jac_y(y, uhat, p))
     phi_fun_jac_y_.generate(fun_name, casadi_opts)
 
-    fun_name = model_name + '_gnsf_phi_jac_y_uhat'
+    fun_name = f"{model_name}_gnsf_phi_jac_y_uhat"
     phi_jac_y_uhat = model.phi_jac_y_uhat
     phi_jac_y_uhat_ = Function(fun_name, [y, uhat, p], phi_jac_y_uhat(y, uhat, p))
     phi_jac_y_uhat_.generate(fun_name, casadi_opts)
 
-    fun_name = model_name + '_gnsf_f_lo_fun_jac_x1k1uz'
+    fun_name = f"{model_name}_gnsf_f_lo_fun_jac_x1k1uz"
     f_lo_fun_jac_x1k1uz = model.f_lo_fun_jac_x1k1uz
     f_lo_fun_jac_x1k1uz_eval = f_lo_fun_jac_x1k1uz(x1, x1dot, z1, u, p)
 
@@ -115,7 +115,7 @@

                  f_lo_fun_jac_x1k1uz_eval)
     f_lo_fun_jac_x1k1uz_.generate(fun_name, casadi_opts)
 
-    fun_name = model_name + '_gnsf_get_matrices_fun'
+    fun_name = f"{model_name}_gnsf_get_matrices_fun"
     get_matrices_fun_ = Function(fun_name, [dummy], get_matrices_fun(1))
     get_matrices_fun_.generate(fun_name, casadi_opts)
 
--- /Users/braandon/openpilot/pyextra/acados_template/utils.py

+++ 

@@ -48,7 +48,7 @@

         acados_path = os.path.join(acados_template_path, '../../../')
         ACADOS_PATH = os.path.realpath(acados_path)
         msg = 'Warning: Did not find environment variable ACADOS_SOURCE_DIR, '
-        msg += 'guessed ACADOS_PATH to be {}.\n'.format(ACADOS_PATH)
+        msg += f'guessed ACADOS_PATH to be {ACADOS_PATH}.\n'
         msg += 'Please export ACADOS_SOURCE_DIR to not avoid this warning.'
         print(msg)
     return ACADOS_PATH
@@ -70,10 +70,10 @@

 
 def casadi_version_warning(casadi_version):
     msg =  'Warning: Please note that the following versions of CasADi  are '
-    msg += 'officially supported: {}.\n '.format(" or ".join(ALLOWED_CASADI_VERSIONS))
+    msg += f"officially supported: {' or '.join(ALLOWED_CASADI_VERSIONS)}.\n "
     msg += 'If there is an incompatibility with the CasADi generated code, '
     msg += 'please consider changing your CasADi version.\n'
-    msg += 'Version {} currently in use.'.format(casadi_version)
+    msg += f'Version {casadi_version} currently in use.'
     print(msg)
 
 
@@ -134,7 +134,7 @@

     elif isinstance(x, SX):
         symbol = SX.sym
     else:
-        raise Exception("model.x must be casadi.SX or casadi.MX, got {}".format(type(x)))
+        raise Exception(f"model.x must be casadi.SX or casadi.MX, got {type(x)}")
 
     if is_empty(p):
         model.p = symbol('p', 0, 0)
@@ -157,24 +157,24 @@

         repo_url, TERA_VERSION, TERA_VERSION, platform2tera[sys.platform])
 
     manual_install = 'For manual installation follow these instructions:\n'
-    manual_install += '1 Download binaries from {}\n'.format(url)
-    manual_install += '2 Copy them in {}/bin\n'.format(acados_path)
+    manual_install += f'1 Download binaries from {url}\n'
+    manual_install += f'2 Copy them in {acados_path}/bin\n'
     manual_install += '3 Strip the version and platform from the binaries: '
     manual_install += 'as t_renderer-v0.0.34-X -> t_renderer)\n'
     manual_install += '4 Enable execution privilege on the file "t_renderer" with:\n'
-    manual_install += '"chmod +x {}"\n\n'.format(tera_path)
+    manual_install += f'"chmod +x {tera_path}"\n\n'
 
     msg = "\n"
     msg += 'Tera template render executable not found, '
-    msg += 'while looking in path:\n{}\n'.format(tera_path)
+    msg += f'while looking in path:\n{tera_path}\n'
     msg += 'In order to be able to render the templates, '
     msg += 'you need to download the tera renderer binaries from:\n'
-    msg += '{}\n\n'.format(repo_url)
+    msg += f'{repo_url}\n\n'
     msg += 'Do you wish to set up Tera renderer automatically?\n'
     msg += 'y/N? (press y to download tera or any key for manual installation)\n'
 
     if input(msg) == 'y':
-        print("Dowloading {}".format(url))
+        print(f"Dowloading {url}")
         with urllib.request.urlopen(url) as response, open(tera_path, 'wb') as out_file:
             shutil.copyfileobj(response, out_file)
         print("Successfully downloaded t_renderer.")
@@ -200,20 +200,14 @@

     # setting up loader and environment
     acados_path = os.path.dirname(os.path.abspath(__file__))
 
-    template_glob = acados_path + '/c_templates_tera/*'
-    acados_template_path = acados_path + '/c_templates_tera'
+    template_glob = f"{acados_path}/c_templates_tera/*"
+    acados_template_path = f"{acados_path}/c_templates_tera"
 
     # call tera as system cmd
-    os_cmd = "{tera_path} '{template_glob}' '{in_file}' '{json_path}' '{out_file}'".format(
-        tera_path=tera_path,
-        template_glob=template_glob,
-        json_path=json_path,
-        in_file=in_file,
-        out_file=out_file
-    )
+    os_cmd = f"{tera_path} '{template_glob}' '{in_file}' '{json_path}' '{out_file}'"
     status = os.system(os_cmd)
     if (status != 0):
-        raise Exception('Rendering of {} failed! Exiting.\n'.format(in_file))
+        raise Exception(f'Rendering of {in_file} failed! Exiting.\n')
 
     os.chdir(cwd)
 
@@ -228,7 +222,7 @@

         return np_array.full()
     else:
         raise(Exception(
-            "Cannot convert to list type {}".format(type(np_array))
+            f"Cannot convert to list type {type(np_array)}"
         ))
 
 
@@ -276,7 +270,7 @@

     # load JSON layout
     current_module = sys.modules[__name__]
     acados_path = os.path.dirname(current_module.__file__)
-    with open(acados_path + '/acados_layout.json', 'r') as f:
+    with open(f"{acados_path}/acados_layout.json", 'r') as f:
         ocp_nlp_layout = json.load(f)
 
     ocp_check_against_layout_recursion(ocp_nlp, ocp_dims, ocp_nlp_layout)
@@ -372,7 +366,7 @@

     model_name = model.name
 
     # create struct with impl_dae_fun, casadi_version
-    fun_name = model_name + '_impl_dae_fun'
+    fun_name = f"{model_name}_impl_dae_fun"
     impl_dae_fun = Function(fun_name, [x, xdot, u, z, p], [f_impl])
 
     casadi_version = CasadiMeta.version()
@@ -381,7 +375,7 @@

     dae_dict = {"str_impl_dae_fun": str_impl_dae_fun, "casadi_version": casadi_version}
 
     # dump
-    json_file = model_name + '_acados_dae.json'
+    json_file = f"{model_name}_acados_dae.json"
     with open(json_file, 'w') as f:
         json.dump(dae_dict, f, default=np_array_to_list, indent=4, sort_keys=True)
     print("dumped ", model_name, " dae to file:", json_file, "\n")
--- /Users/braandon/openpilot/pyextra/acados_template/generate_c_code_implicit_ode.py

+++ 

@@ -80,10 +80,10 @@

 
     ## Set up functions
     p = model.p
-    fun_name = model_name + '_impl_dae_fun'
+    fun_name = f"{model_name}_impl_dae_fun"
     impl_dae_fun = Function(fun_name, [x, xdot, u, z, p], [f_impl])
 
-    fun_name = model_name + '_impl_dae_fun_jac_x_xdot_z'
+    fun_name = f"{model_name}_impl_dae_fun_jac_x_xdot_z"
     impl_dae_fun_jac_x_xdot_z = Function(fun_name, [x, xdot, u, z, p], [f_impl, jac_x, jac_xdot, jac_z])
 
     # fun_name = model_name + '_impl_dae_fun_jac_x_xdot_z'
@@ -92,17 +92,17 @@

     # fun_name = model_name + '_impl_dae_jac_x_xdot_u'
     # impl_dae_jac_x_xdot_u = Function(fun_name, [x, xdot, u, z, p], [jac_x, jac_xdot, jac_u, jac_z])
 
-    fun_name = model_name + '_impl_dae_fun_jac_x_xdot_u_z'
+    fun_name = f"{model_name}_impl_dae_fun_jac_x_xdot_u_z"
     impl_dae_fun_jac_x_xdot_u_z = Function(fun_name, [x, xdot, u, z, p], [f_impl, jac_x, jac_xdot, jac_u, jac_z])
 
-    fun_name = model_name + '_impl_dae_fun_jac_x_xdot_u'
+    fun_name = f"{model_name}_impl_dae_fun_jac_x_xdot_u"
     impl_dae_fun_jac_x_xdot_u = Function(fun_name, [x, xdot, u, z, p], [f_impl, jac_x, jac_xdot, jac_u])
 
-    fun_name = model_name + '_impl_dae_jac_x_xdot_u_z'
+    fun_name = f"{model_name}_impl_dae_jac_x_xdot_u_z"
     impl_dae_jac_x_xdot_u_z = Function(fun_name, [x, xdot, u, z, p], [jac_x, jac_xdot, jac_u, jac_z])
 
 
-    fun_name = model_name + '_impl_dae_hess'
+    fun_name = f"{model_name}_impl_dae_hess"
     impl_dae_hess = Function(fun_name, [x, xdot, u, z, multiplier, p], [HESS])
 
     # generate C code
@@ -111,29 +111,29 @@

 
     cwd = os.getcwd()
     os.chdir(code_export_dir)
-    model_dir = model_name + '_model'
+    model_dir = f"{model_name}_model"
     if not os.path.exists(model_dir):
         os.mkdir(model_dir)
-    model_dir_location = './' + model_dir
+    model_dir_location = f"./{model_dir}"
     os.chdir(model_dir_location)
 
-    fun_name = model_name + '_impl_dae_fun'
+    fun_name = f"{model_name}_impl_dae_fun"
     impl_dae_fun.generate(fun_name, casadi_opts)
 
-    fun_name = model_name + '_impl_dae_fun_jac_x_xdot_z'
+    fun_name = f"{model_name}_impl_dae_fun_jac_x_xdot_z"
     impl_dae_fun_jac_x_xdot_z.generate(fun_name, casadi_opts)
 
-    fun_name = model_name + '_impl_dae_jac_x_xdot_u_z'
+    fun_name = f"{model_name}_impl_dae_jac_x_xdot_u_z"
     impl_dae_jac_x_xdot_u_z.generate(fun_name, casadi_opts)
 
-    fun_name = model_name + '_impl_dae_fun_jac_x_xdot_u_z'
+    fun_name = f"{model_name}_impl_dae_fun_jac_x_xdot_u_z"
     impl_dae_fun_jac_x_xdot_u_z.generate(fun_name, casadi_opts)
 
-    fun_name = model_name + '_impl_dae_fun_jac_x_xdot_u'
+    fun_name = f"{model_name}_impl_dae_fun_jac_x_xdot_u"
     impl_dae_fun_jac_x_xdot_u.generate(fun_name, casadi_opts)
 
     if generate_hess:
-        fun_name = model_name + '_impl_dae_hess'
+        fun_name = f"{model_name}_impl_dae_hess"
         impl_dae_hess.generate(fun_name, casadi_opts)
 
     os.chdir(cwd)
Skipping fstrings transform of file /Users/braandon/openpilot/pyextra/acados_template/acados_ocp.py due to unknown encoding: future_fstrings.
--- /Users/braandon/openpilot/pyextra/acados_template/generate_c_code_discrete_dynamics.py

+++ 

@@ -57,7 +57,7 @@

     elif isinstance(phi, casadi.SX):
         symbol = SX.sym
     else:
-        Exception("generate_c_code_disc_dyn: disc_dyn_expr must be a CasADi expression, you have type: {}".format(type(phi)))
+        Exception(f"generate_c_code_disc_dyn: disc_dyn_expr must be a CasADi expression, you have type: {type(phi)}")
 
     # assume nx1 = nx !!!
     lam = symbol('lam', nx, 1)
@@ -77,22 +77,22 @@

 
     cwd = os.getcwd()
     os.chdir(code_export_dir)
-    model_dir = model_name + '_model'
+    model_dir = f"{model_name}_model"
     if not os.path.exists(model_dir):
         os.mkdir(model_dir)
-    model_dir_location = './' + model_dir
+    model_dir_location = f"./{model_dir}"
     os.chdir(model_dir_location)
 
     # set up & generate Functions
-    fun_name = model_name + '_dyn_disc_phi_fun'
+    fun_name = f"{model_name}_dyn_disc_phi_fun"
     phi_fun = Function(fun_name, [x, u, p], [phi])
     phi_fun.generate(fun_name, casadi_opts)
 
-    fun_name = model_name + '_dyn_disc_phi_fun_jac'
+    fun_name = f"{model_name}_dyn_disc_phi_fun_jac"
     phi_fun_jac_ut_xt = Function(fun_name, [x, u, p], [phi, jac_ux.T])
     phi_fun_jac_ut_xt.generate(fun_name, casadi_opts)
 
-    fun_name = model_name + '_dyn_disc_phi_fun_jac_hess'
+    fun_name = f"{model_name}_dyn_disc_phi_fun_jac_hess"
     phi_fun_jac_ut_xt_hess = Function(fun_name, [x, u, lam, p], [phi, jac_ux.T, hess_ux])
     phi_fun_jac_ut_xt_hess.generate(fun_name, casadi_opts)
     
--- /Users/braandon/openpilot/pyextra/acados_template/acados_ocp_solver_fast.py

+++ 

@@ -142,7 +142,7 @@

                 # Get elements in column major order
                 value_ = np.ravel(value_, order='F')
             else:
-                raise Exception("Unknown api: '{}'".format(api))
+                raise Exception(f"Unknown api: '{api}'")
 
         if value_shape != expected_shape:
             raise Exception('AcadosOcpSolver.cost_set(): mismatching dimension',
@@ -217,7 +217,7 @@

                 # Get elements in column major order
                 value_ = np.ravel(value_, order='F')
             else:
-                raise Exception("Unknown api: '{}'".format(api))
+                raise Exception(f"Unknown api: '{api}'")
         if value_shape != expected_shape:
             raise Exception('AcadosOcpSolver.constraints_set(): mismatching dimension' \
                 ' for field "{}" with dimension {} (you have {})'.format(field_, expected_shape, value_shape))
@@ -289,8 +289,8 @@

                 self.nlp_dims, self.nlp_out, stage_, field)
 
             if value_.shape[0] != dims:
-                msg = 'AcadosOcpSolver.set(): mismatching dimension for field "{}" '.format(field_)
-                msg += 'with dimension {} (you have {})'.format(dims, value_.shape)
+                msg = f'AcadosOcpSolver.set(): mismatching dimension for field "{field_}" '
+                msg += f'with dimension {dims} (you have {value_.shape})'
                 raise Exception(msg)
 
             value_data = cast(value_.ctypes.data, POINTER(c_double))
@@ -357,7 +357,7 @@

             raise Exception('AcadosOcpSolver.get_slice(): end stage index must be larger than start stage index')
 
         if start_stage_ < 0 or end_stage_ > self.N + 1:
-            raise Exception('AcadosOcpSolver.get_slice(): stage index must be in [0, N], got: {}.'.format(self.N))
+            raise Exception(f'AcadosOcpSolver.get_slice(): stage index must be in [0, N], got: {self.N}.')
         self.shared_lib.ocp_nlp_dims_get_from_attr.argtypes = \
             [c_void_p, c_void_p, c_void_p, c_int, c_char_p]
         self.shared_lib.ocp_nlp_dims_get_from_attr.restype = c_int
--- /Users/braandon/openpilot/pyextra/acados_template/generate_c_code_nls_cost.py

+++ 

@@ -73,10 +73,10 @@

 
     cwd = os.getcwd()
     os.chdir(code_export_dir)
-    gen_dir = cost_name + '_cost'
+    gen_dir = f"{cost_name}_cost"
     if not os.path.exists(gen_dir):
         os.mkdir(gen_dir)
-    gen_dir_location = './' + gen_dir
+    gen_dir_location = f"./{gen_dir}"
     os.chdir(gen_dir_location)
 
     # set up expressions
Skipping fstrings transform of file /Users/braandon/openpilot/pyextra/acados_template/acados_sim.py due to unknown encoding: future_fstrings.
--- /Users/braandon/openpilot/pyextra/acados_template/generate_c_code_constraint.py

+++ 

@@ -91,18 +91,18 @@

 
         cwd = os.getcwd()
         os.chdir(code_export_dir)
-        gen_dir = con_name + '_constraints'
+        gen_dir = f"{con_name}_constraints"
         if not os.path.exists(gen_dir):
             os.mkdir(gen_dir)
-        gen_dir_location = './' + gen_dir
+        gen_dir_location = f"./{gen_dir}"
         os.chdir(gen_dir_location)
 
         # export casadi functions
         if constr_type == 'BGH':
             if is_terminal:
-                fun_name = con_name + '_constr_h_e_fun_jac_uxt_zt'
+                fun_name = f"{con_name}_constr_h_e_fun_jac_uxt_zt"
             else:
-                fun_name = con_name + '_constr_h_fun_jac_uxt_zt'
+                fun_name = f"{con_name}_constr_h_fun_jac_uxt_zt"
 
             jac_ux_t = transpose(jacobian(con_h_expr, vertcat(u,x)))
             jac_z_t = jacobian(con_h_expr, z)
@@ -113,9 +113,9 @@

             if opts['generate_hess']:
 
                 if is_terminal:
-                    fun_name = con_name + '_constr_h_e_fun_jac_uxt_zt_hess'
+                    fun_name = f"{con_name}_constr_h_e_fun_jac_uxt_zt_hess"
                 else:
-                    fun_name = con_name + '_constr_h_fun_jac_uxt_zt_hess'
+                    fun_name = f"{con_name}_constr_h_fun_jac_uxt_zt_hess"
 
                 # adjoint
                 adj_ux = jtimes(con_h_expr, vertcat(u, x), lam_h, True)
@@ -134,19 +134,19 @@

                 constraint_fun_jac_tran_hess.generate(fun_name, casadi_opts)
 
             if is_terminal:
-                fun_name = con_name + '_constr_h_e_fun'
+                fun_name = f"{con_name}_constr_h_e_fun"
             else:
-                fun_name = con_name + '_constr_h_fun'
+                fun_name = f"{con_name}_constr_h_fun"
             h_fun = Function(fun_name, [x, u, z, p], [con_h_expr])
             h_fun.generate(fun_name, casadi_opts)
 
         else: # BGP constraint
             if is_terminal:
-                fun_name = con_name + '_phi_e_constraint'
+                fun_name = f"{con_name}_phi_e_constraint"
                 r = model.con_r_in_phi_e
                 con_r_expr = model.con_r_expr_e
             else:
-                fun_name = con_name + '_phi_constraint'
+                fun_name = f"{con_name}_phi_constraint"
                 r = model.con_r_in_phi
                 con_r_expr = model.con_r_expr
 
Skipping fstrings transform of file /Users/braandon/openpilot/pyextra/acados_template/acados_ocp_solver.py due to unknown encoding: future_fstrings.
--- /Users/braandon/openpilot/panda/python/update.py

+++ 

@@ -37,7 +37,7 @@

 
   assert(not panda.bootstub)
   version = str(panda.get_version())
-  print("%s should be %s" % (version, repo_version))
+  print(f"{version} should be {repo_version}")
   assert(version.startswith(repo_version))
 
 if __name__ == "__main__":
--- /Users/braandon/openpilot/panda/python/dfu.py

+++ 

@@ -28,7 +28,7 @@

           self._mcu_type = self.get_mcu_type(device)
           self._handle = device.open()
           return
-    raise Exception("failed to open " + dfu_serial if dfu_serial is not None else "DFU device")
+    raise Exception(f"failed to open {dfu_serial}" if dfu_serial is not None else "DFU device")
 
   @staticmethod
   def list():
--- /Users/braandon/openpilot/panda/python/__init__.py

+++ 

@@ -270,7 +270,7 @@

   def flash(self, fn=DEFAULT_FW_FN, code=None, reconnect=True):
     if self._mcu_type == MCU_TYPE_H7 and fn == DEFAULT_FW_FN:
       fn = DEFAULT_H7_FW_FN
-    print("flash: main version is " + self.get_version())
+    print(f"flash: main version is {self.get_version()}")
     if not self.bootstub:
       self.reset(enter_bootstub=True)
     assert(self.bootstub)
@@ -280,7 +280,7 @@

         code = f.read()
 
     # get version
-    print("flash: bootstub version is " + self.get_version())
+    print(f"flash: bootstub version is {self.get_version()}")
 
     # do flash
     Panda.flash_static(self._handle, code)
@@ -309,14 +309,14 @@

 
   @staticmethod
   def flash_ota_st():
-    ret = os.system("cd %s && make clean && make ota" % (os.path.join(BASEDIR, "board")))
+    ret = os.system(f"cd {os.path.join(BASEDIR, 'board')} && make clean && make ota")
     time.sleep(1)
     return ret == 0
 
   @staticmethod
   def flash_ota_wifi(release=False):
     release_str = "RELEASE=1" if release else ""
-    ret = os.system("cd {} && make clean && {} make ota".format(os.path.join(BASEDIR, "boardesp"), release_str))
+    ret = os.system(f"cd {os.path.join(BASEDIR, 'boardesp')} && make clean && {release_str} make ota")
     time.sleep(1)
     return ret == 0
 
--- /Users/braandon/openpilot/panda/python/uds.py

+++ 

@@ -307,7 +307,7 @@

       msgs = self.rx()
       if drain:
         if self.debug:
-          print("CAN-RX: drain - {}".format(len(msgs)))
+          print(f"CAN-RX: drain - {len(msgs)}")
         self.rx_buff.clear()
       else:
         for rx_addr, _, rx_data, rx_bus in msgs or []:
@@ -504,7 +504,7 @@

     # standard 29 bit response addr (flip last two bytes)
     return (tx_addr & 0xFFFF0000) + (tx_addr << 8 & 0xFF00) + (tx_addr >> 8 & 0xFF)
 
-  raise ValueError("invalid tx_addr: {}".format(tx_addr))
+  raise ValueError(f"invalid tx_addr: {tx_addr}")
 
 
 class UdsClient():
@@ -559,12 +559,12 @@

           if self.debug:
             print("UDS-RX: response pending")
           continue
-        raise NegativeResponseError('{} - {}'.format(service_desc, error_desc), service_id, error_code)
+        raise NegativeResponseError(f'{service_desc} - {error_desc}', service_id, error_code)
 
       # positive response
       if service_type + 0x40 != resp_sid:
         resp_sid_hex = hex(resp_sid) if resp_sid is not None else None
-        raise InvalidServiceIdError('invalid response service id: {}'.format(resp_sid_hex))
+        raise InvalidServiceIdError(f'invalid response service id: {resp_sid_hex}')
 
       if subfunction is not None:
         resp_sfn = resp[1] if len(resp) > 1 else None
@@ -666,21 +666,21 @@

     resp = self._uds_request(SERVICE_TYPE.READ_DATA_BY_IDENTIFIER, subfunction=None, data=data)
     resp_id = struct.unpack('!H', resp[0:2])[0] if len(resp) >= 2 else None
     if resp_id != data_identifier_type:
-      raise ValueError('invalid response data identifier: {} expected: {}'.format(hex(resp_id), hex(data_identifier_type)))
+      raise ValueError(f'invalid response data identifier: {hex(resp_id)} expected: {hex(data_identifier_type)}')
     return resp[2:]
 
   def read_memory_by_address(self, memory_address: int, memory_size: int, memory_address_bytes: int = 4, memory_size_bytes: int = 1):
     if memory_address_bytes < 1 or memory_address_bytes > 4:
-      raise ValueError('invalid memory_address_bytes: {}'.format(memory_address_bytes))
+      raise ValueError(f'invalid memory_address_bytes: {memory_address_bytes}')
     if memory_size_bytes < 1 or memory_size_bytes > 4:
-      raise ValueError('invalid memory_size_bytes: {}'.format(memory_size_bytes))
+      raise ValueError(f'invalid memory_size_bytes: {memory_size_bytes}')
     data = bytes([memory_size_bytes << 4 | memory_address_bytes])
 
     if memory_address >= 1 << (memory_address_bytes * 8):
-      raise ValueError('invalid memory_address: {}'.format(memory_address))
+      raise ValueError(f'invalid memory_address: {memory_address}')
     data += struct.pack('!I', memory_address)[4 - memory_address_bytes:]
     if memory_size >= 1 << (memory_size_bytes * 8):
-      raise ValueError('invalid memory_size: {}'.format(memory_size))
+      raise ValueError(f'invalid memory_size: {memory_size}')
     data += struct.pack('!I', memory_size)[4 - memory_size_bytes:]
 
     resp = self._uds_request(SERVICE_TYPE.READ_MEMORY_BY_ADDRESS, subfunction=None, data=data)
@@ -691,7 +691,7 @@

     resp = self._uds_request(SERVICE_TYPE.READ_SCALING_DATA_BY_IDENTIFIER, subfunction=None, data=data)
     resp_id = struct.unpack('!H', resp[0:2])[0] if len(resp) >= 2 else None
     if resp_id != data_identifier_type:
-      raise ValueError('invalid response data identifier: {}'.format(hex(resp_id)))
+      raise ValueError(f'invalid response data identifier: {hex(resp_id)}')
     return resp[2:]  # TODO: parse the response
 
   def read_data_by_periodic_identifier(self, transmission_mode_type: TRANSMISSION_MODE_TYPE, periodic_data_identifier: int):
@@ -702,9 +702,9 @@

   def dynamically_define_data_identifier(self, dynamic_definition_type: DYNAMIC_DEFINITION_TYPE, dynamic_data_identifier: int,
                                          source_definitions: List[DynamicSourceDefinition], memory_address_bytes: int = 4, memory_size_bytes: int = 1):
     if memory_address_bytes < 1 or memory_address_bytes > 4:
-      raise ValueError('invalid memory_address_bytes: {}'.format(memory_address_bytes))
+      raise ValueError(f'invalid memory_address_bytes: {memory_address_bytes}')
     if memory_size_bytes < 1 or memory_size_bytes > 4:
-      raise ValueError('invalid memory_size_bytes: {}'.format(memory_size_bytes))
+      raise ValueError(f'invalid memory_size_bytes: {memory_size_bytes}')
 
     data = struct.pack('!H', dynamic_data_identifier)
     if dynamic_definition_type == DYNAMIC_DEFINITION_TYPE.DEFINE_BY_IDENTIFIER:
@@ -714,15 +714,15 @@

       data += bytes([memory_size_bytes << 4 | memory_address_bytes])
       for s in source_definitions:
         if s.memory_address >= 1 << (memory_address_bytes * 8):
-          raise ValueError('invalid memory_address: {}'.format(s.memory_address))
+          raise ValueError(f'invalid memory_address: {s.memory_address}')
         data += struct.pack('!I', s.memory_address)[4 - memory_address_bytes:]
         if s.memory_size >= 1 << (memory_size_bytes * 8):
-          raise ValueError('invalid memory_size: {}'.format(s.memory_size))
+          raise ValueError(f'invalid memory_size: {s.memory_size}')
         data += struct.pack('!I', s.memory_size)[4 - memory_size_bytes:]
     elif dynamic_definition_type == DYNAMIC_DEFINITION_TYPE.CLEAR_DYNAMICALLY_DEFINED_DATA_IDENTIFIER:
       pass
     else:
-      raise ValueError('invalid dynamic identifier type: {}'.format(hex(dynamic_definition_type)))
+      raise ValueError(f'invalid dynamic identifier type: {hex(dynamic_definition_type)}')
     self._uds_request(SERVICE_TYPE.DYNAMICALLY_DEFINE_DATA_IDENTIFIER, subfunction=dynamic_definition_type, data=data)
 
   def write_data_by_identifier(self, data_identifier_type: DATA_IDENTIFIER_TYPE, data_record: bytes):
@@ -730,20 +730,20 @@

     resp = self._uds_request(SERVICE_TYPE.WRITE_DATA_BY_IDENTIFIER, subfunction=None, data=data)
     resp_id = struct.unpack('!H', resp[0:2])[0] if len(resp) >= 2 else None
     if resp_id != data_identifier_type:
-      raise ValueError('invalid response data identifier: {}'.format(hex(resp_id)))
+      raise ValueError(f'invalid response data identifier: {hex(resp_id)}')
 
   def write_memory_by_address(self, memory_address: int, memory_size: int, data_record: bytes, memory_address_bytes: int = 4, memory_size_bytes: int = 1):
     if memory_address_bytes < 1 or memory_address_bytes > 4:
-      raise ValueError('invalid memory_address_bytes: {}'.format(memory_address_bytes))
+      raise ValueError(f'invalid memory_address_bytes: {memory_address_bytes}')
     if memory_size_bytes < 1 or memory_size_bytes > 4:
-      raise ValueError('invalid memory_size_bytes: {}'.format(memory_size_bytes))
+      raise ValueError(f'invalid memory_size_bytes: {memory_size_bytes}')
     data = bytes([memory_size_bytes << 4 | memory_address_bytes])
 
     if memory_address >= 1 << (memory_address_bytes * 8):
-      raise ValueError('invalid memory_address: {}'.format(memory_address))
+      raise ValueError(f'invalid memory_address: {memory_address}')
     data += struct.pack('!I', memory_address)[4 - memory_address_bytes:]
     if memory_size >= 1 << (memory_size_bytes * 8):
-      raise ValueError('invalid memory_size: {}'.format(memory_size))
+      raise ValueError(f'invalid memory_size: {memory_size}')
     data += struct.pack('!I', memory_size)[4 - memory_size_bytes:]
 
     data += data_record
@@ -797,7 +797,7 @@

     resp = self._uds_request(SERVICE_TYPE.INPUT_OUTPUT_CONTROL_BY_IDENTIFIER, subfunction=None, data=data)
     resp_id = struct.unpack('!H', resp[0:2])[0] if len(resp) >= 2 else None
     if resp_id != data_identifier_type:
-      raise ValueError('invalid response data identifier: {}'.format(hex(resp_id)))
+      raise ValueError(f'invalid response data identifier: {hex(resp_id)}')
     return resp[2:]
 
   def routine_control(self, routine_control_type: ROUTINE_CONTROL_TYPE, routine_identifier_type: ROUTINE_IDENTIFIER_TYPE, routine_option_record: bytes = b''):
@@ -805,23 +805,23 @@

     resp = self._uds_request(SERVICE_TYPE.ROUTINE_CONTROL, subfunction=routine_control_type, data=data)
     resp_id = struct.unpack('!H', resp[0:2])[0] if len(resp) >= 2 else None
     if resp_id != routine_identifier_type:
-      raise ValueError('invalid response routine identifier: {}'.format(hex(resp_id)))
+      raise ValueError(f'invalid response routine identifier: {hex(resp_id)}')
     return resp[2:]
 
   def request_download(self, memory_address: int, memory_size: int, memory_address_bytes: int = 4, memory_size_bytes: int = 4, data_format: int = 0x00):
     data = bytes([data_format])
 
     if memory_address_bytes < 1 or memory_address_bytes > 4:
-      raise ValueError('invalid memory_address_bytes: {}'.format(memory_address_bytes))
+      raise ValueError(f'invalid memory_address_bytes: {memory_address_bytes}')
     if memory_size_bytes < 1 or memory_size_bytes > 4:
-      raise ValueError('invalid memory_size_bytes: {}'.format(memory_size_bytes))
+      raise ValueError(f'invalid memory_size_bytes: {memory_size_bytes}')
     data += bytes([memory_size_bytes << 4 | memory_address_bytes])
 
     if memory_address >= 1 << (memory_address_bytes * 8):
-      raise ValueError('invalid memory_address: {}'.format(memory_address))
+      raise ValueError(f'invalid memory_address: {memory_address}')
     data += struct.pack('!I', memory_address)[4 - memory_address_bytes:]
     if memory_size >= 1 << (memory_size_bytes * 8):
-      raise ValueError('invalid memory_size: {}'.format(memory_size))
+      raise ValueError(f'invalid memory_size: {memory_size}')
     data += struct.pack('!I', memory_size)[4 - memory_size_bytes:]
 
     resp = self._uds_request(SERVICE_TYPE.REQUEST_DOWNLOAD, subfunction=None, data=data)
@@ -829,7 +829,7 @@

     if max_num_bytes_len >= 1 and max_num_bytes_len <= 4:
       max_num_bytes = struct.unpack('!I', (b"\x00" * (4 - max_num_bytes_len)) + resp[1:max_num_bytes_len + 1])[0]
     else:
-      raise ValueError('invalid max_num_bytes_len: {}'.format(max_num_bytes_len))
+      raise ValueError(f'invalid max_num_bytes_len: {max_num_bytes_len}')
 
     return max_num_bytes  # max number of bytes per transfer data request
 
@@ -837,16 +837,16 @@

     data = bytes([data_format])
 
     if memory_address_bytes < 1 or memory_address_bytes > 4:
-      raise ValueError('invalid memory_address_bytes: {}'.format(memory_address_bytes))
+      raise ValueError(f'invalid memory_address_bytes: {memory_address_bytes}')
     if memory_size_bytes < 1 or memory_size_bytes > 4:
-      raise ValueError('invalid memory_size_bytes: {}'.format(memory_size_bytes))
+      raise ValueError(f'invalid memory_size_bytes: {memory_size_bytes}')
     data += bytes([memory_size_bytes << 4 | memory_address_bytes])
 
     if memory_address >= 1 << (memory_address_bytes * 8):
-      raise ValueError('invalid memory_address: {}'.format(memory_address))
+      raise ValueError(f'invalid memory_address: {memory_address}')
     data += struct.pack('!I', memory_address)[4 - memory_address_bytes:]
     if memory_size >= 1 << (memory_size_bytes * 8):
-      raise ValueError('invalid memory_size: {}'.format(memory_size))
+      raise ValueError(f'invalid memory_size: {memory_size}')
     data += struct.pack('!I', memory_size)[4 - memory_size_bytes:]
 
     resp = self._uds_request(SERVICE_TYPE.REQUEST_UPLOAD, subfunction=None, data=data)
@@ -854,7 +854,7 @@

     if max_num_bytes_len >= 1 and max_num_bytes_len <= 4:
       max_num_bytes = struct.unpack('!I', (b"\x00" * (4 - max_num_bytes_len)) + resp[1:max_num_bytes_len + 1])[0]
     else:
-      raise ValueError('invalid max_num_bytes_len: {}'.format(max_num_bytes_len))
+      raise ValueError(f'invalid max_num_bytes_len: {max_num_bytes_len}')
 
     return max_num_bytes  # max number of bytes per transfer data request
 
@@ -863,7 +863,7 @@

     resp = self._uds_request(SERVICE_TYPE.TRANSFER_DATA, subfunction=None, data=data)
     resp_id = resp[0] if len(resp) > 0 else None
     if resp_id != block_sequence_count:
-      raise ValueError('invalid block_sequence_count: {}'.format(resp_id))
+      raise ValueError(f'invalid block_sequence_count: {resp_id}')
     return resp[1:]
 
   def request_transfer_exit(self):
--- /Users/braandon/openpilot/panda/python/flash_release.py

+++ 

@@ -11,7 +11,7 @@

   from zipfile import ZipFile
 
   def status(x):
-    print("\033[1;32;40m" + x + "\033[00m")
+    print(f"[1;32;40m{x}[00m")
 
   if st_serial is not None:
     # look for Panda
@@ -21,21 +21,21 @@

     elif len(panda_list) > 1:
       raise Exception("Please only connect one panda")
     st_serial = panda_list[0]
-    print("Using panda with serial %s" % st_serial)
+    print(f"Using panda with serial {st_serial}")
 
   if path is None:
     print("Fetching latest firmware from github.com/commaai/panda-artifacts")
     r = requests.get("https://raw.githubusercontent.com/commaai/panda-artifacts/master/latest.json")
     url = json.loads(r.text)['url']
     r = requests.get(url)
-    print("Fetching firmware from %s" % url)
+    print(f"Fetching firmware from {url}")
     path = io.BytesIO(r.content)
 
   zf = ZipFile(path)
   zf.printdir()
 
   version = zf.read("version").decode().strip()
-  status("0. Preparing to flash " + str(version))
+  status(f"0. Preparing to flash {str(version)}")
 
   code_bootstub = zf.read("bootstub.panda.bin")
   code_panda = zf.read("panda.bin")
@@ -63,7 +63,7 @@

   status("4. Verifying version")
   panda = Panda(st_serial)
   my_version = panda.get_version()
-  print("dongle id: %s" % panda.get_serial()[0])
+  print(f"dongle id: {panda.get_serial()[0]}")
   print(my_version, "should be", version)
   assert(str(version) == str(my_version))
 
--- /Users/braandon/openpilot/panda/tests/elm_car_simulator.py

+++ 

@@ -108,7 +108,7 @@

 
     def _lin_send(self, to_addr, msg):
         if not self.__silent:
-            print("    LIN Reply (%x)" % to_addr, binascii.hexlify(msg))
+            print(f"    LIN Reply ({to_addr:x})", binascii.hexlify(msg))
 
         PHYS_ADDR = 0x80
         #FUNC_ADDR = 0xC0
@@ -202,7 +202,7 @@

 
     def _can_send(self, addr, msg):
         if not self.__silent:
-            print("    CAN Reply (%x)" % addr, binascii.hexlify(msg))
+            print(f"    CAN Reply ({addr:x})", binascii.hexlify(msg))
         self.panda.can_send(addr, msg + b'\x00' * (8 - len(msg)), 0)
         if self.__can_extra_noise_msgs:
             noise = self.__can_extra_noise_msgs.popleft()
--- /Users/braandon/openpilot/panda/tests/standalone_test.py

+++ 

@@ -19,7 +19,7 @@

   for i in range(100):
     p.get_serial()
   t2 = time.time()
-  print("100 requests took %.2f ms" % ((t2 - t1) * 1000))
+  print(f"100 requests took {(t2 - t1) * 1000:.2f} ms")
 
   p.set_safety_mode(Panda.SAFETY_ALLOUTPUT)
 
--- /Users/braandon/openpilot/panda/tests/get_version.py

+++ 

@@ -4,5 +4,5 @@

 if __name__ == "__main__":
   for p in Panda.list():
     pp = Panda(p)
-    print("%s: %s" % (pp.get_serial()[0], pp.get_version()))
+    print(f"{pp.get_serial()[0]}: {pp.get_version()}")
 
--- /Users/braandon/openpilot/panda/tests/can_printer.py

+++ 

@@ -28,8 +28,8 @@

         msgs[address].append(dat)
 
     if sec_since_boot() - lp > 0.1:
-      dd = chr(27) + "[2J"
-      dd += "%5.2f\n" % (sec_since_boot() - start)
+      dd = f"{chr(27)}[2J"
+      dd += f"{sec_since_boot() - start:5.2f}\n"
       for k, v in sorted(zip(list(msgs.keys()), [binascii.hexlify(x[-1]) for x in list(msgs.values())])):
         dd += "%s(%6d) %s\n" % ("%04X(%4d)" % (k, k), len(msgs[k]), v)
       print(dd)
--- /Users/braandon/openpilot/panda/tests/gps_stability_test.py

+++ 

@@ -65,7 +65,7 @@

     cs = 0
     for i in d:
       cs ^= ord(i)
-    return msg + "*%02X" % cs
+    return f"{msg}*{cs:02X}"
 
   ser = PandaSerial(panda, 1, INIT_GPS_BAUD)
 
@@ -78,7 +78,7 @@

 
   # Upping baud rate
   print("Upping GPS baud rate")
-  msg = str.encode(add_nmea_checksum("$PUBX,41,1,0007,0003,%d,0" % GPS_BAUD) + "\r\n")
+  msg = str.encode(f"{add_nmea_checksum('$PUBX,41,1,0007,0003,%d,0' % GPS_BAUD)}\r\n")
   ser.write(msg)
   time.sleep(1)   # needs a wait for it to actually send
 
@@ -147,16 +147,16 @@

   while True:
     time.sleep(CHECK_PERIOD)
     if(received_bytes < MIN_BYTES):
-      print("Panda is not sending out enough data! Got " + str(received_messages) + " (" + str(received_bytes) + "B) in the last " + str(CHECK_PERIOD) + " seconds")
+      print(f"Panda is not sending out enough data! Got {str(received_messages)} ({str(received_bytes)}B) in the last {str(CHECK_PERIOD)} seconds")
       send_something = True
       min_failures += 1
     elif(received_bytes > MAX_BYTES):
-      print("Panda is not sending out too much data! Got " + str(received_messages) + " (" + str(received_bytes) + "B) in the last " + str(CHECK_PERIOD) + " seconds")
+      print(f"Panda is not sending out too much data! Got {str(received_messages)} ({str(received_bytes)}B) in the last {str(CHECK_PERIOD)} seconds")
       print("Probably not on the right baud rate, got reset somehow? Resetting...")
       max_failures += 1
       init_gps(gps_panda)
     else:
-      print("Got " + str(received_messages) + " (" + str(received_bytes) + "B) messages in the last " + str(CHECK_PERIOD) + " seconds.")
+      print(f"Got {str(received_messages)} ({str(received_bytes)}B) messages in the last {str(CHECK_PERIOD)} seconds.")
       if(min_failures > 0):
         print("Total min failures: ", min_failures)
       if(max_failures > 0):
--- /Users/braandon/openpilot/panda/tests/location_listener.py

+++ 

@@ -11,7 +11,7 @@

   cs = 0
   for i in d:
     cs ^= ord(i)
-  return msg + "*%02X" % cs
+  return f"{msg}*{cs:02X}"
 
 if __name__ == "__main__":
   panda = Panda()
@@ -30,7 +30,7 @@

   baudrate = 460800
 
   print("upping baud rate")
-  msg = str.encode(add_nmea_checksum("$PUBX,41,1,0007,0003,%d,0" % baudrate) + "\r\n")
+  msg = str.encode(f"{add_nmea_checksum('$PUBX,41,1,0007,0003,%d,0' % baudrate)}\r\n")
   print(msg)
   ser.write(msg)
   time.sleep(0.1)  # needs a wait for it to actually send
--- /Users/braandon/openpilot/panda/tests/read_winusb_descriptors.py

+++ 

@@ -11,24 +11,24 @@

   print('Microsoft OS String Descriptor')
   dat = p._handle.controlRead(Panda.REQUEST_IN, 0x06, 3 << 8 | 238, 0, length[0])
   if DEBUG:
-    print('LEN: {}'.format(hex(length[0])))
+    print(f'LEN: {hex(length[0])}')
   hexdump("".join(map(chr, dat)))
 
   ms_vendor_code = dat[16]
   if DEBUG:
-    print('MS_VENDOR_CODE: {}'.format(hex(length[0])))
+    print(f'MS_VENDOR_CODE: {hex(length[0])}')
 
   print('\nMicrosoft Compatible ID Feature Descriptor')
   length = p._handle.controlRead(Panda.REQUEST_IN, ms_vendor_code, 0, 4, 1)
   if DEBUG:
-    print('LEN: {}'.format(hex(length[0])))
+    print(f'LEN: {hex(length[0])}')
   dat = p._handle.controlRead(Panda.REQUEST_IN, ms_vendor_code, 0, 4, length[0])
   hexdump("".join(map(chr, dat)))
 
   print('\nMicrosoft Extended Properties Feature Descriptor')
   length = p._handle.controlRead(Panda.REQUEST_IN, ms_vendor_code, 0, 5, 1)
   if DEBUG:
-    print('LEN: {}'.format(hex(length[0])))
+    print(f'LEN: {hex(length[0])}')
   dat = p._handle.controlRead(Panda.REQUEST_IN, ms_vendor_code, 0, 5, length[0])
   hexdump("".join(map(chr, dat)))
 
--- /Users/braandon/openpilot/panda/tests/automated/4_can_loopback.py

+++ 

@@ -39,7 +39,7 @@

         assert_greater(saturation_pct, 80)
         assert_less(saturation_pct, 100)
 
-        print("two pandas bus {}, 100 messages at speed {:4d}, comp speed is {:7.2f}, percent {:6.2f}".format(bus, speed, comp_kbps, saturation_pct))
+        print(f"two pandas bus {bus}, 100 messages at speed {speed:4d}, comp speed is {comp_kbps:7.2f}, percent {saturation_pct:6.2f}")
 
   # Start heartbeat
   start_heartbeat_thread(p)
@@ -105,7 +105,7 @@

             r_echo = p_send.can_recv()
 
           if len(r) == 0 or len(r_echo) == 0:
-            print("r: {}, r_echo: {}".format(r, r_echo))
+            print(f"r: {r}, r_echo: {r_echo}")
 
           assert_equal(len(r), 1)
           assert_equal(len(r_echo), 1)
--- /Users/braandon/openpilot/panda/tests/automated/helpers.py

+++ 

@@ -141,7 +141,7 @@

           found = True
           break
       if not found:
-        raise IOError("No unused panda found for type: {}".format(p_type))
+        raise IOError(f"No unused panda found for type: {p_type}")
     return fn(serials, **kwargs)
   return wrapper
 
--- /Users/braandon/openpilot/panda/tests/safety/test_volkswagen_mqb.py

+++ 

@@ -53,7 +53,7 @@

 
   # Wheel speeds _esp_19_msg
   def _speed_msg(self, speed):
-    values = {"ESP_%s_Radgeschw_02" % s: speed for s in ["HL", "HR", "VL", "VR"]}
+    values = {f"ESP_{s}_Radgeschw_02": speed for s in ["HL", "HR", "VL", "VR"]}
     return self.packer.make_can_msg_panda("ESP_19", 0, values)
 
   # Brake light switch _esp_05_msg
--- /Users/braandon/openpilot/panda/tests/safety/test_gm.py

+++ 

@@ -52,7 +52,7 @@

     raise NotImplementedError
 
   def _speed_msg(self, speed):
-    values = {"%sWheelSpd" % s: speed for s in ["RL", "RR"]}
+    values = {f"{s}WheelSpd": speed for s in ["RL", "RR"]}
     return self.packer.make_can_msg_panda("EBCMWheelSpdRear", 0, values)
 
   def _button_msg(self, buttons):
--- /Users/braandon/openpilot/panda/tests/safety/test_nissan.py

+++ 

@@ -53,7 +53,7 @@

 
   def _speed_msg(self, speed):
     # TODO: why the 3.6? m/s to kph? not in dbc
-    values = {"WHEEL_SPEED_%s" % s: speed * 3.6 for s in ["RR", "RL"]}
+    values = {f"WHEEL_SPEED_{s}": speed * 3.6 for s in ["RR", "RL"]}
     return self.packer.make_can_msg_panda("WHEEL_SPEEDS_REAR", 0, values)
 
   def _brake_msg(self, brake):
--- /Users/braandon/openpilot/panda/tests/safety/test_toyota.py

+++ 

@@ -55,7 +55,7 @@

     return self.packer.make_can_msg_panda("ACC_CONTROL", 0, values)
 
   def _speed_msg(self, speed):
-    values = {("WHEEL_SPEED_%s" % n): speed for n in ["FR", "FL", "RR", "RL"]}
+    values = {(f"WHEEL_SPEED_{n}"): speed for n in ["FR", "FL", "RR", "RL"]}
     return self.packer.make_can_msg_panda("WHEEL_SPEEDS", 0, values)
 
   def _brake_msg(self, brake):
--- /Users/braandon/openpilot/panda/tests/safety/common.py

+++ 

@@ -422,7 +422,7 @@

 
     all_tx = []
     for tf in test_files:
-      test = importlib.import_module("panda.tests.safety."+tf[:-3])
+      test = importlib.import_module(f"panda.tests.safety.{tf[:-3]}")
       for attr in dir(test):
         if attr.startswith("Test") and attr != current_test:
           tx = getattr(getattr(test, attr), "TX_MSGS")
--- /Users/braandon/openpilot/panda/tests/safety/test_hyundai.py

+++ 

@@ -93,7 +93,7 @@

 
   def _speed_msg(self, speed):
     # panda safety doesn't scale, so undo the scaling
-    values = {"WHL_SPD_%s" % s: speed * 0.03125 for s in ["FL", "FR", "RL", "RR"]}
+    values = {f"WHL_SPD_{s}": speed * 0.03125 for s in ["FL", "FR", "RL", "RR"]}
     values["WHL_SPD_AliveCounter_LSB"] = (self.cnt_speed % 16) & 0x3
     values["WHL_SPD_AliveCounter_MSB"] = (self.cnt_speed % 16) >> 2
     self.__class__.cnt_speed += 1
--- /Users/braandon/openpilot/panda/examples/can_unique.py

+++ 

@@ -64,7 +64,7 @@

     for row in reader:
       bus = row[2]
       message_id = hex(int(row[1]))[2:]
-      message_id = '%s:%s' % (bus, message_id)
+      message_id = f'{bus}:{message_id}'
       data = row[3]
       self.store(message_id, data)
 
@@ -75,7 +75,7 @@

         message_id = row[1][2:]  # remove leading '0x'
       else:
         message_id = hex(int(row[1]))[2:]  # old message IDs are in decimal
-      message_id = '%s:%s' % (bus, message_id)
+      message_id = f'{bus}:{message_id}'
       if row[1].startswith('0x'):
         data = row[2][2:]  # remove leading '0x'
       else:
@@ -103,7 +103,7 @@

   interesting.load(interesting_file)
   for message_id in sorted(interesting.messages):
     if message_id not in background.messages:
-      print('New message_id: %s' % message_id)
+      print(f'New message_id: {message_id}')
     else:
       interesting.messages[message_id].printBitDiff(
           background.messages[message_id])
@@ -111,7 +111,7 @@

 
 if __name__ == "__main__":
   if len(sys.argv) < 3:
-    print('Usage:\n%s interesting.csv background*.csv' % sys.argv[0])
+    print(f'Usage:\n{sys.argv[0]} interesting.csv background*.csv')
     sys.exit(0)
   PrintUnique(sys.argv[1], sys.argv[2:])
 
--- /Users/braandon/openpilot/panda/examples/query_vin_and_stats.py

+++ 

@@ -37,7 +37,7 @@

   isotp_send(panda, b"\x09\x02", 0x7df)
   ret = isotp_recv(panda, 0x7e8)
   hexdump(ret)
-  print("VIN: %s" % "".join(map(chr, ret[:2])))
+  print(f"VIN: {''.join(map(chr, ret[:2]))}")
 
   # 03 = get DTCS
   isotp_send(panda, b"\x03", 0x7e0)
--- /Users/braandon/openpilot/panda/examples/can_bit_transition.py

+++ 

@@ -45,7 +45,7 @@

           message_id = row[1][2:]  # remove leading '0x'
         else:
           message_id = hex(int(row[1]))[2:]  # old message IDs are in decimal
-        message_id = '%s:%s' % (bus, message_id)
+        message_id = f'{bus}:{message_id}'
         if row[3].startswith('0x'):
           data = row[3][2:]  # remove leading '0x'
         else:
@@ -83,7 +83,7 @@

 
 if __name__ == "__main__":
   if len(sys.argv) < 4:
-    print('Usage:\n%s log.csv <low-start>-<low-end> <high-start>-<high-end>' % sys.argv[0])
+    print(f'Usage:\n{sys.argv[0]} log.csv <low-start>-<low-end> <high-start>-<high-end>')
     sys.exit(0)
   PrintUnique(sys.argv[1], sys.argv[2], sys.argv[3])
 
--- /Users/braandon/openpilot/panda/examples/get_panda_password.py

+++ 

@@ -13,8 +13,8 @@

     sys.exit(0)
 
   wifi = p.get_serial()
-  print("SSID: " + wifi[0])
-  print("Password: " + wifi[1])
+  print(f"SSID: {wifi[0]}")
+  print(f"Password: {wifi[1]}")
 
 if __name__ == "__main__":
   get_panda_password()
--- /Users/braandon/openpilot/panda/examples/tesla_tester.py

+++ 

@@ -53,10 +53,10 @@

           vin_index = int(binascii.hexlify(dat)[:2])  # first byte is the index, 00, 01, 02
           vin_string = binascii.hexlify(dat)[2:]  # rest of the string is the actual VIN data
           vin[vin_index] = vin_string.decode("hex")
-          print("Got VIN index " + str(vin_index) + " data " + vin[vin_index])
+          print(f"Got VIN index {str(vin_index)} data {vin[vin_index]}")
     #if we have all 3 parts of the VIN, print it and break out of our while loop
     if 0 in vin and 1 in vin and 2 in vin:
-      print("VIN: " + vin[0] + vin[1] + vin[2][:3])
+      print(f"VIN: {vin[0]}{vin[1]}{vin[2][:3]}")
       break
 
 if __name__ == "__main__":
--- /Users/braandon/openpilot/rednose_repo/rednose/helpers/ekf_sym.py

+++ 

@@ -464,7 +464,7 @@

     # rewind
     if self.filter_time is not None and t < self.filter_time:
       if len(self.rewind_t) == 0 or t < self.rewind_t[0] or t < self.rewind_t[-1] - self.max_rewind_age:
-        self.logger.error("observation too old at %.3f with filter at %.3f, ignoring" % (t, self.filter_time))
+        self.logger.error(f"observation too old at {t:.3f} with filter at {self.filter_time:.3f}, ignoring")
         return None
       rewound = self.rewind(t)
     else:
--- /Users/braandon/openpilot/rednose_repo/rednose/helpers/lst_sq_computer.py

+++ 

@@ -54,7 +54,7 @@

     code += "\n#define KDIM %d\n" % K
     code += "extern \"C\" {\n"
     code += sympy_code
-    code += "\n" + open(os.path.join(TEMPLATE_DIR, "compute_pos.c")).read() + "\n"
+    code += f"\n{open(os.path.join(TEMPLATE_DIR, 'compute_pos.c')).read()}\n"
     code += "}\n"
 
     header += "\nvoid compute_pos(double *to_c, double *in_poses, double *in_img_positions, double *param, double *pos);\n"
--- /Users/braandon/openpilot/rednose_repo/rednose/helpers/chi2_lookup.py

+++ 

@@ -13,7 +13,7 @@

 
 
 def chi2_ppf(p, dim):
-  table = np.load(os.path.dirname(os.path.realpath(__file__)) + '/chi2_lookup_table.npy')
+  table = np.load(f"{os.path.dirname(os.path.realpath(__file__))}/chi2_lookup_table.npy")
   result = np.interp(p, np.arange(.01, .99, .01), table[dim])
   return result
 
--- /Users/braandon/openpilot/rednose_repo/rednose/helpers/feature_handler.py

+++ 

@@ -36,7 +36,7 @@

     c_code += "#include <string.h>\n"
     c_code += "#define K %d\n" % K
     c_code += "extern \"C\" {\n"
-    c_code += "\n" + open(os.path.join(TEMPLATE_DIR, "feature_handler.c")).read()
+    c_code += f"\n{open(os.path.join(TEMPLATE_DIR, 'feature_handler.c')).read()}"
     c_code += "\n}\n"
 
     filename = f"{FeatureHandler.name}_{K}"
--- /Users/braandon/openpilot/rednose_repo/site_scons/site_tools/cython.py

+++ 

@@ -17,8 +17,8 @@

   matches += pyx_import_re.findall(contents)
 
   # Modules can be either .pxd or .pyx files
-  files = [m.replace('.', '/') + '.pxd' for m in matches]
-  files += [m.replace('.', '/') + '.pyx' for m in matches]
+  files = [f"{m.replace('.', '/')}.pxd" for m in matches]
+  files += [f"{m.replace('.', '/')}.pyx" for m in matches]
 
   # cdef extern from <file>
   files += cdef_import_re.findall(contents)
--- /Users/braandon/openpilot/selfdrive/updated.py

+++ 

@@ -309,7 +309,7 @@

   new_version = cur_hash != upstream_hash
   git_fetch_result = check_git_fetch_result(git_fetch_output)
 
-  cloudlog.info("comparing %s to %s" % (cur_hash, upstream_hash))
+  cloudlog.info(f"comparing {cur_hash} to {upstream_hash}")
   if new_version or git_fetch_result:
     cloudlog.info("Running update")
 
--- /Users/braandon/openpilot/selfdrive/version.py

+++ 

@@ -36,8 +36,8 @@

 def get_git_remote(default: Optional[str] = None) -> Optional[str]:
   try:
     local_branch = run_cmd(["git", "name-rev", "--name-only", "HEAD"])
-    tracking_remote = run_cmd(["git", "config", "branch." + local_branch + ".remote"])
-    return run_cmd(["git", "config", "remote." + tracking_remote + ".url"])
+    tracking_remote = run_cmd(["git", "config", f"branch.{local_branch}.remote"])
+    return run_cmd(["git", "config", f"remote.{tracking_remote}.url"])
   except subprocess.CalledProcessError:  # Not on a branch, fallback
     return run_cmd_default(["git", "config", "--get", "remote.origin.url"], default=default)
 
@@ -100,9 +100,9 @@

   params.put("TermsVersion", terms_version)
   params.put("TrainingVersion", training_version)
 
-  print("Dirty: %s" % dirty)
-  print("Version: %s" % version)
-  print("Remote: %s" % origin)
-  print("Branch: %s" % branch)
-  print("Prebuilt: %s" % prebuilt)
+  print(f"Dirty: {dirty}")
+  print(f"Version: {version}")
+  print(f"Remote: {origin}")
+  print(f"Branch: {branch}")
+  print(f"Prebuilt: {prebuilt}")
 
--- /Users/braandon/openpilot/selfdrive/tombstoned.py

+++ 

@@ -42,7 +42,7 @@

 
 
 def clear_apport_folder():
-  for f in glob.glob(APPORT_DIR + '*'):
+  for f in glob.glob(f"{APPORT_DIR}*"):
     try:
       os.remove(f)
     except Exception:
@@ -146,11 +146,11 @@

         path = path.replace('/data/openpilot/', '')
         message += path
       elif "Signal" in line:
-        message += " - " + line.strip()
+        message += f" - {line.strip()}"
 
         try:
           sig_num = int(line.strip().split(': ')[-1])
-          message += " (" + signal.Signals(sig_num).name + ")"  # pylint: disable=no-member
+          message += f" ({signal.Signals(sig_num).name})"  # pylint: disable=no-member
         except ValueError:
           pass
 
@@ -175,8 +175,8 @@

     crash_function = " ".join(x for x in crash_function.split(' ')[1:] if not x.startswith('0x'))
     crash_function = re.sub(r'\(.*?\)', '', crash_function)
 
-  contents = stacktrace + "\n\n" + contents
-  message = message + " - " + crash_function
+  contents = f"{stacktrace}\n\n{contents}"
+  message = f"{message} - {crash_function}"
   sentry_report(fn, message, contents)
 
   # Copy crashlog to upload folder
--- /Users/braandon/openpilot/selfdrive/ui/tests/cycle_offroad_alerts.py

+++ 

@@ -20,7 +20,7 @@

     params.put_bool("UpdateAvailable", True)
     r = open(os.path.join(BASEDIR, "RELEASES.md"), "r").read()
     r = r[:r.find('\n\n')]  # Slice latest release notes
-    params.put("ReleaseNotes", r + "\n")
+    params.put("ReleaseNotes", f"{r}\n")
 
     time.sleep(t)
     params.put_bool("UpdateAvailable", False)
--- /Users/braandon/openpilot/selfdrive/car/fw_versions.py

+++ 

@@ -330,7 +330,7 @@

   print("Getting vin...")
   addr, vin = get_vin(logcan, sendcan, 1, retry=10, debug=args.debug)
   print(f"VIN: {vin}")
-  print("Getting VIN took %.3f s" % (time.time() - t))
+  print(f"Getting VIN took {time.time() - t:.3f} s")
   print()
 
   t = time.time()
@@ -347,5 +347,5 @@

 
   print()
   print("Possible matches:", candidates)
-  print("Getting fw took %.3f s" % (time.time() - t))
-
+  print(f"Getting fw took {time.time() - t:.3f} s")
+
--- /Users/braandon/openpilot/selfdrive/car/fingerprints.py

+++ 

@@ -8,10 +8,10 @@

   # - values are attr values from all car folders
   result = result()
 
-  for car_folder in [x[0] for x in os.walk(BASEDIR + '/selfdrive/car')]:
+  for car_folder in [x[0] for x in os.walk(f"{BASEDIR}/selfdrive/car")]:
     try:
       car_name = car_folder.split('/')[-1]
-      values = __import__('selfdrive.car.%s.values' % car_name, fromlist=[attr])
+      values = __import__(f'selfdrive.car.{car_name}.values', fromlist=[attr])
       if hasattr(values, attr):
         attr_values = getattr(values, attr)
       else:
--- /Users/braandon/openpilot/selfdrive/car/car_helpers.py

+++ 

@@ -39,16 +39,16 @@

 def load_interfaces(brand_names):
   ret = {}
   for brand_name in brand_names:
-    path = ('selfdrive.car.%s' % brand_name)
-    CarInterface = __import__(path + '.interface', fromlist=['CarInterface']).CarInterface
+    path = f'selfdrive.car.{brand_name}'
+    CarInterface = __import__(f"{path}.interface", fromlist=['CarInterface']).CarInterface
 
-    if os.path.exists(BASEDIR + '/' + path.replace('.', '/') + '/carstate.py'):
-      CarState = __import__(path + '.carstate', fromlist=['CarState']).CarState
+    if os.path.exists(f"{BASEDIR}/{path.replace('.', '/')}/carstate.py"):
+      CarState = __import__(f"{path}.carstate", fromlist=['CarState']).CarState
     else:
       CarState = None
 
-    if os.path.exists(BASEDIR + '/' + path.replace('.', '/') + '/carcontroller.py'):
-      CarController = __import__(path + '.carcontroller', fromlist=['CarController']).CarController
+    if os.path.exists(f"{BASEDIR}/{path.replace('.', '/')}/carcontroller.py"):
+      CarController = __import__(f"{path}.carcontroller", fromlist=['CarController']).CarController
     else:
       CarController = None
 
@@ -62,10 +62,10 @@

   # - keys are all the car names that which we have an interface for
   # - values are lists of spefic car models for a given car
   brand_names = {}
-  for car_folder in [x[0] for x in os.walk(BASEDIR + '/selfdrive/car')]:
+  for car_folder in [x[0] for x in os.walk(f"{BASEDIR}/selfdrive/car")]:
     try:
       brand_name = car_folder.split('/')[-1]
-      model_names = __import__('selfdrive.car.%s.values' % brand_name, fromlist=['CAR']).CAR
+      model_names = __import__(f'selfdrive.car.{brand_name}.values', fromlist=['CAR']).CAR
       model_names = [getattr(model_names, c) for c in model_names.__dict__.keys() if not c.startswith("__")]
       brand_names[brand_name] = model_names
     except (ImportError, IOError):
--- /Users/braandon/openpilot/selfdrive/car/volkswagen/interface.py

+++ 

@@ -136,7 +136,7 @@

       ret.wheelbase = 2.84
 
     else:
-      raise ValueError("unsupported car %s" % candidate)
+      raise ValueError(f"unsupported car {candidate}")
 
     ret.rotationalInertia = scale_rot_inertia(ret.mass, ret.wheelbase)
     ret.centerToFront = ret.wheelbase * 0.45
--- /Users/braandon/openpilot/selfdrive/car/tests/test_car_interfaces.py

+++ 

@@ -59,7 +59,7 @@

       car_interface.apply(CC)
 
     # Test radar interface
-    RadarInterface = importlib.import_module('selfdrive.car.%s.radar_interface' % car_params.carName).RadarInterface
+    RadarInterface = importlib.import_module(f'selfdrive.car.{car_params.carName}.radar_interface').RadarInterface
     radar_interface = RadarInterface(car_params)
     assert radar_interface
 
--- /Users/braandon/openpilot/selfdrive/car/honda/interface.py

+++ 

@@ -279,7 +279,7 @@

       ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV = [[0.6], [0.18]] # TODO: can probably use some tuning
 
     else:
-      raise ValueError("unsupported car %s" % candidate)
+      raise ValueError(f"unsupported car {candidate}")
 
     # These cars use alternate user brake msg (0x1BE)
     if candidate in HONDA_BOSCH_ALT_BRAKE_SIGNAL:
--- /Users/braandon/openpilot/selfdrive/hardware/tici/power_monitor.py

+++ 

@@ -40,7 +40,7 @@

       power_average = average(power_average, power)
       power_total_average = average(power_total_average, power_total)
 
-      print("%12.2f mW %12.2f mW %12.2f mW" % (power, power_total, power_total-power))
+      print(f"{power:12.2f} mW {power_total:12.2f} mW {power_total - power:12.2f} mW")
       time.sleep(0.25)
   finally:
     stop_time = time.monotonic()
@@ -48,7 +48,7 @@

     voltage = voltage_average[0]
     current = current_average[0]
     power = power_average[0]
-    print("%.2f volts %12.2f ma %12.2f mW %12.2f mW" % (voltage, current, power, power_total))
-    print("  {:.2f} Seconds     {} samples".format(stop_time - start_time, voltage_average[1]))
+    print(f"{voltage:.2f} volts {current:12.2f} ma {power:12.2f} mW {power_total:12.2f} mW")
+    print(f"  {stop_time - start_time:.2f} Seconds     {voltage_average[1]} samples")
     print("----------------------------------------------------------------")
 
--- /Users/braandon/openpilot/selfdrive/hardware/tici/hardware.py

+++ 

@@ -10,15 +10,15 @@

 from selfdrive.hardware.tici import iwlist
 
 NM = 'org.freedesktop.NetworkManager'
-NM_CON_ACT = NM + '.Connection.Active'
-NM_DEV_WL = NM + '.Device.Wireless'
-NM_AP = NM + '.AccessPoint'
+NM_CON_ACT = f"{NM}.Connection.Active"
+NM_DEV_WL = f"{NM}.Device.Wireless"
+NM_AP = f"{NM}.AccessPoint"
 DBUS_PROPS = 'org.freedesktop.DBus.Properties'
 
 MM = 'org.freedesktop.ModemManager1'
-MM_MODEM = MM + ".Modem"
-MM_MODEM_SIMPLE = MM + ".Modem.Simple"
-MM_SIM = MM + ".Sim"
+MM_MODEM = f"{MM}.Modem"
+MM_MODEM_SIMPLE = f"{MM}.Modem.Simple"
+MM_SIM = f"{MM}.Sim"
 
 class MM_MODEM_STATE(IntEnum):
        FAILED        = -1
--- /Users/braandon/openpilot/selfdrive/hardware/eon/test_neos_updater.py

+++ 

@@ -36,7 +36,7 @@

       with tempfile.NamedTemporaryFile(delete=False, dir=os.getcwd()) as f:
         dat = os.urandom(random.randint(1000, 100000))
         f.write(dat)
-        cls.manifest[f"{i}_url"] = f"http://localhost:{PORT}/" + os.path.relpath(f.name)
+        cls.manifest[f"{i}_url"] = f"http://localhost:{PORT}/{os.path.relpath(f.name)}"
         cls.manifest[F"{i}_hash"] = hashlib.sha256(dat).hexdigest()
         if i == "recovery":
           cls.manifest["recovery_len"] = len(dat)
@@ -88,7 +88,7 @@

     Path(get_fn(self.manifest['ota_url'])).touch()
     with self.assertRaisesRegex(Exception, "failed hash check"):
       download_file(self.manifest['ota_url'], get_fn(self.manifest['ota_url']),
-                    self.manifest['ota_hash']+'a', "system")
+                    f"{self.manifest['ota_hash']}a", "system")
 
     # should've unlinked after the failed hash check, should succeed now
     download_file(self.manifest['ota_url'], get_fn(self.manifest['ota_url']),
--- /Users/braandon/openpilot/selfdrive/test/update_ci_routes.py

+++ 

@@ -25,7 +25,7 @@

     "azcopy",
     "copy",
     f"{path}/*",
-    "https://{}.blob.core.windows.net/{}/{}?{}".format(_DATA_ACCOUNT_CI, "openpilotci", destpath, DEST_KEY),
+    f"https://{_DATA_ACCOUNT_CI}.blob.core.windows.net/openpilotci/{destpath}?{DEST_KEY}",
     "--recursive=false",
     "--overwrite=false",
     "--exclude-pattern=*/dcamera.hevc",
@@ -46,8 +46,8 @@

     cmd = [
       "azcopy",
       "copy",
-      "https://{}.blob.core.windows.net/{}/{}?{}".format(source_account, source_bucket, key_prefix, source_key),
-      "https://{}.blob.core.windows.net/{}/{}?{}".format(_DATA_ACCOUNT_CI, "openpilotci", dongle_id, DEST_KEY),
+      f"https://{source_account}.blob.core.windows.net/{source_bucket}/{key_prefix}?{source_key}",
+      f"https://{_DATA_ACCOUNT_CI}.blob.core.windows.net/openpilotci/{dongle_id}?{DEST_KEY}",
       "--recursive=true",
       "--overwrite=false",
       "--exclude-pattern=*/dcamera.hevc",
--- /Users/braandon/openpilot/selfdrive/test/test_fingerprints.py

+++ 

@@ -15,10 +15,10 @@

   # - keys are all the car names that which we have a fingerprint dict for
   # - values are dicts of fingeprints for each trim
   fingerprints = {}
-  for car_folder in [x[0] for x in os.walk(BASEDIR + '/selfdrive/car')]:
+  for car_folder in [x[0] for x in os.walk(f"{BASEDIR}/selfdrive/car")]:
     car_name = car_folder.split('/')[-1]
     try:
-      fingerprints[car_name] = __import__('selfdrive.car.%s.values' % car_name, fromlist=['FINGERPRINTS']).FINGERPRINTS
+      fingerprints[car_name] = __import__(f'selfdrive.car.{car_name}.values', fromlist=['FINGERPRINTS']).FINGERPRINTS
     except (ImportError, IOError, AttributeError):
       pass
 
@@ -78,14 +78,14 @@

   for idx2, f2 in enumerate(fingerprints_flat):
     if idx1 < idx2 and not check_fingerprint_consistency(f1, f2):
       valid = False
-      print("Those two fingerprints are inconsistent {0} {1}".format(car_names[idx1], car_names[idx2]))
+      print(f"Those two fingerprints are inconsistent {car_names[idx1]} {car_names[idx2]}")
       print("")
       print(', '.join("%d: %d" % v for v in sorted(f1.items())))
       print("")
       print(', '.join("%d: %d" % v for v in sorted(f2.items())))
       print("")
 
-print("Found {0} individual fingerprints".format(len(fingerprints_flat)))
+print(f"Found {len(fingerprints_flat)} individual fingerprints")
 if not valid or len(fingerprints_flat) == 0:
   print("TEST FAILED")
   sys.exit(1)
--- /Users/braandon/openpilot/selfdrive/test/openpilotci.py

+++ 

@@ -9,7 +9,7 @@

 
 def get_url(route_name, segment_num, log_type="rlog"):
   ext = "hevc" if log_type in ["fcamera", "dcamera"] else "bz2"
-  return BASE_URL + "%s/%s/%s.%s" % (route_name.replace("|", "/"), segment_num, log_type, ext)
+  return f"{BASE_URL}{route_name.replace('|', '/')}/{segment_num}/{log_type}.{ext}"
 
 def upload_file(path, name):
   from azure.storage.blob import BlockBlobService
@@ -23,7 +23,7 @@

                                          --expiry $(date -u '+%Y-%m-%dT%H:%M:%SZ' -d '+1 hour') --auth-mode login --as-user --output tsv", shell=True).decode().strip("\n")
   service = BlockBlobService(account_name="commadataci", sas_token=sas_token)
   service.create_blob_from_path("openpilotci", name, path)
-  return "https://commadataci.blob.core.windows.net/openpilotci/" + name
+  return f"https://commadataci.blob.core.windows.net/openpilotci/{name}"
 
 if __name__ == "__main__":
   for f in sys.argv[1:]:
--- /Users/braandon/openpilot/selfdrive/test/test_valgrind_replay.py

+++ 

@@ -51,7 +51,7 @@

   def valgrindlauncher(self, arg, cwd):
     os.chdir(os.path.join(BASEDIR, cwd))
     # Run valgrind on a process
-    command = "valgrind --leak-check=full " + arg
+    command = f"valgrind --leak-check=full {arg}"
     p = subprocess.Popen(command, stderr=subprocess.PIPE, shell=True, preexec_fn=os.setsid)  # pylint: disable=W1509
     while not self.done:
       time.sleep(0.1)
--- /Users/braandon/openpilot/selfdrive/test/test_models.py

+++ 

@@ -114,7 +114,7 @@

 
   def test_radar_interface(self):
     os.environ['NO_RADAR_SLEEP'] = "1"
-    RadarInterface = importlib.import_module('selfdrive.car.%s.radar_interface' % self.CP.carName).RadarInterface
+    RadarInterface = importlib.import_module(f'selfdrive.car.{self.CP.carName}.radar_interface').RadarInterface
     RI = RadarInterface(self.CP)
     assert RI
 
--- /Users/braandon/openpilot/selfdrive/test/process_replay/test_processes.py

+++ 

@@ -72,7 +72,7 @@

           break
     else:
       segment = cmp_log_fn.split("/")[-1].split("_")[0]
-      raise Exception("Route never enabled: %s" % segment)
+      raise Exception(f"Route never enabled: {segment}")
 
   try:
     return compare_logs(cmp_log_msgs, log_msgs, ignore_fields+cfg.ignore, ignore_msgs, cfg.tolerance)
@@ -81,30 +81,30 @@

 
 def format_diff(results, ref_commit):
   diff1, diff2 = "", ""
-  diff2 += "***** tested against commit %s *****\n" % ref_commit
+  diff2 += f"***** tested against commit {ref_commit} *****\n"
 
   failed = False
   for segment, result in list(results.items()):
-    diff1 += "***** results for segment %s *****\n" % segment
-    diff2 += "***** differences for segment %s *****\n" % segment
+    diff1 += f"***** results for segment {segment} *****\n"
+    diff2 += f"***** differences for segment {segment} *****\n"
 
     for proc, diff in list(result.items()):
-      diff1 += "\t%s\n" % proc
-      diff2 += "*** process: %s ***\n" % proc
+      diff1 += f"\t{proc}\n"
+      diff2 += f"*** process: {proc} ***\n"
 
       if isinstance(diff, str):
-        diff1 += "\t\t%s\n" % diff
+        diff1 += f"\t\t{diff}\n"
         failed = True
       elif len(diff):
         cnt = {}
         for d in diff:
-          diff2 += "\t%s\n" % str(d)
+          diff2 += f"\t{str(d)}\n"
 
           k = str(d[1])
           cnt[k] = 1 if k not in cnt else cnt[k] + 1
 
         for k, v in sorted(cnt.items()):
-          diff1 += "\t\t%s: %s\n" % (k, v)
+          diff1 += f"\t\t{k}: {v}\n"
         failed = True
   return diff1, diff2, failed
 
@@ -137,13 +137,13 @@

     print("couldn't find reference commit")
     sys.exit(1)
 
-  print("***** testing against commit %s *****" % ref_commit)
+  print(f"***** testing against commit {ref_commit} *****")
 
   # check to make sure all car brands are tested
   if FULL_TEST:
     tested_cars = set(c.lower() for c, _ in segments)
     untested = (set(interface_names) - set(excluded_interfaces)) - tested_cars
-    assert len(untested) == 0, "Cars missing routes: %s" % (str(untested))
+    assert len(untested) == 0, f"Cars missing routes: {str(untested)}"
 
   results: Any = {}
   for car_brand, segment in segments:
@@ -151,7 +151,7 @@

        (not cars_whitelisted and car_brand.upper() in args.blacklist_cars):
       continue
 
-    print("***** testing route segment %s *****\n" % segment)
+    print(f"***** testing route segment {segment} *****\n")
 
     results[segment] = {}
 
@@ -163,7 +163,7 @@

          (not procs_whitelisted and cfg.proc_name in args.blacklist_procs):
         continue
 
-      cmp_log_fn = os.path.join(process_replay_dir, "%s_%s_%s.bz2" % (segment, cfg.proc_name, ref_commit))
+      cmp_log_fn = os.path.join(process_replay_dir, f"{segment}_{cfg.proc_name}_{ref_commit}.bz2")
       results[segment][cfg.proc_name] = test_process(cfg, lr, cmp_log_fn, args.ignore_fields, args.ignore_msgs)
 
   diff1, diff2, failed = format_diff(results, ref_commit)
--- /Users/braandon/openpilot/selfdrive/test/process_replay/update_refs.py

+++ 

@@ -28,7 +28,7 @@

 
     for cfg in CONFIGS:
       log_msgs = replay_process(cfg, lr)
-      log_fn = os.path.join(process_replay_dir, "%s_%s_%s.bz2" % (segment, cfg.proc_name, ref_commit))
+      log_fn = os.path.join(process_replay_dir, f"{segment}_{cfg.proc_name}_{ref_commit}.bz2")
       save_log(log_fn, log_msgs)
 
       if not no_upload:
--- /Users/braandon/openpilot/selfdrive/test/process_replay/model_replay.py

+++ 

@@ -109,7 +109,7 @@

   failed = False
   if not update:
     ref_commit = open(ref_commit_fn).read().strip()
-    log_fn = "%s_%s_%s.bz2" % (TEST_ROUTE, "model", ref_commit)
+    log_fn = f"{TEST_ROUTE}_{'model'}_{ref_commit}.bz2"
     cmp_log = LogReader(BASE_URL + log_fn)
 
     ignore = ['logMonoTime', 'valid',
@@ -136,7 +136,7 @@

     print("Uploading new refs")
 
     new_commit = get_git_commit()
-    log_fn = "%s_%s_%s.bz2" % (TEST_ROUTE, "model", new_commit)
+    log_fn = f"{TEST_ROUTE}_{'model'}_{new_commit}.bz2"
     save_log(log_fn, log_msgs)
     try:
       upload_file(log_fn, os.path.basename(log_fn))
--- /Users/braandon/openpilot/selfdrive/test/process_replay/test_fuzzy.py

+++ 

@@ -110,12 +110,12 @@

 def is_finite(d, exclude=[], prefix=""):  # pylint: disable=dangerous-default-value
   ret = True
   for k, v in d.items():
-    name = prefix + f"{k}"
+    name = f"{prefix}{k}"
     if name in exclude:
       continue
 
     if isinstance(v, dict):
-      if not is_finite(v, exclude, name + "."):
+      if not is_finite(v, exclude, f"{name}."):
         ret = False
     else:
       try:
--- /Users/braandon/openpilot/selfdrive/test/process_replay/regen.py

+++ 

@@ -163,7 +163,7 @@

         p.terminate()
 
   r = params.get("CurrentRoute", encoding='utf-8')
-  return os.path.join(outdir, r + "--0")
+  return os.path.join(outdir, f"{r}--0")
 
 
 def regen_and_save(route, sidx, upload=False, use_route_meta=True):
--- /Users/braandon/openpilot/selfdrive/locationd/test/ublox.py

+++ 

@@ -326,27 +326,27 @@

     '''return a formatted string for a message'''
     if not msg._unpacked:
       self.unpack(msg)
-    ret = self.name + ': '
+    ret = f"{self.name}: "
     for f in self.fields:
       (fieldname, alen) = ArrayParse(f)
       if fieldname not in msg._fields:
         continue
       v = msg._fields[fieldname]
       if isinstance(v, list):
-        ret += '%s=[' % fieldname
+        ret += f'{fieldname}=['
         for a in range(alen):
-          ret += '%s, ' % v[a]
-        ret = ret[:-2] + '], '
+          ret += f'{v[a]}, '
+        ret = f"{ret[:-2]}], "
       elif isinstance(v, str):
         ret += '%s="%s", ' % (f, v.rstrip(' \0'))
       else:
-        ret += '%s=%s, ' % (f, v)
+        ret += f'{f}={v}, '
     for r in msg._recs:
       ret += '[ '
       for f in self.fields2:
         v = r[f]
-        ret += '%s=%s, ' % (f, v)
-      ret = ret[:-2] + ' ], '
+        ret += f'{f}={v}, '
+      ret = f"{ret[:-2]} ], "
     return ret[:-2]
 
 
@@ -608,7 +608,7 @@

       raise UBloxError('INVALID MESSAGE')
     type = self.msg_type()
     if type not in msg_types:
-      raise UBloxError('Unknown message %s' % str(type))
+      raise UBloxError(f'Unknown message {str(type)}')
     msg_types[type].pack(self)
 
   def name(self):
@@ -783,7 +783,7 @@

 
   def send_nmea(self, msg):
     if not self.read_only:
-      s = msg + "*%02X" % self.nmea_checksum(msg) + "\r\n"
+      s = f'{msg}*{self.nmea_checksum(msg):02X}\r\n'
       self.write(s)
 
   def set_binary(self):
--- /Users/braandon/openpilot/selfdrive/boardd/tests/boardd_old.py

+++ 

@@ -139,7 +139,7 @@

   can_init()
   cnt = 0
   while 1:
-    can_send_many([[0xbb, 0, "\xaa\xaa\xaa\xaa", 0], [0xaa, 0, "\xaa\xaa\xaa\xaa"+struct.pack("!I", cnt), 1]])
+    can_send_many([[0xbb, 0, "\xaa\xaa\xaa\xaa", 0], [0xaa, 0, f"ªªªª{struct.pack('!I', cnt)}", 1]])
     #can_send_many([[0xaa,0,"\xaa\xaa\xaa\xaa",0]])
     #can_send_many([[0xaa,0,"\xaa\xaa\xaa\xaa",1]])
     # recv @ 100hz
--- /Users/braandon/openpilot/selfdrive/controls/radard.py

+++ 

@@ -183,7 +183,7 @@

 
   # import the radar from the fingerprint
   cloudlog.info("radard is importing %s", CP.carName)
-  RadarInterface = importlib.import_module('selfdrive.car.%s.radar_interface' % CP.carName).RadarInterface
+  RadarInterface = importlib.import_module(f'selfdrive.car.{CP.carName}.radar_interface').RadarInterface
 
   # *** setup messaging
   if can_sock is None:
--- /Users/braandon/openpilot/selfdrive/controls/tests/test_alerts.py

+++ 

@@ -70,7 +70,7 @@

 
         font = fonts[alert.alert_size][i]
         w, _ = draw.textsize(txt, font)
-        msg = "type: %s msg: %s" % (alert.alert_type, txt)
+        msg = f"type: {alert.alert_type} msg: {txt}"
         self.assertLessEqual(w, max_text_width, msg=msg)
 
   def test_alert_sanity_check(self):
--- /Users/braandon/openpilot/selfdrive/controls/lib/radar_helpers.py

+++ 

@@ -146,7 +146,7 @@

     }
 
   def __str__(self):
-    ret = "x: %4.1f  y: %4.1f  v: %4.1f  a: %4.1f" % (self.dRel, self.yRel, self.vRel, self.aLeadK)
+    ret = f"x: {self.dRel:4.1f}  y: {self.yRel:4.1f}  v: {self.vRel:4.1f}  a: {self.aLeadK:4.1f}"
     return ret
 
   def potential_low_speed_lead(self, v_ego):
--- /Users/braandon/openpilot/selfdrive/controls/lib/cluster/fastcluster_py.py

+++ 

@@ -5,7 +5,7 @@

 from common.ffi_wrapper import suffix
 
 cluster_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)))
-cluster_fn = os.path.join(cluster_dir, "libfastcluster"+suffix())
+cluster_fn = os.path.join(cluster_dir, f"libfastcluster{suffix()}")
 
 ffi = FFI()
 ffi.cdef("""
--- /Users/braandon/openpilot/selfdrive/controls/lib/longitudinal_mpc_lib/long_mpc.py

+++ 

@@ -352,8 +352,7 @@

     if self.solution_status != 0:
       if t > self.last_cloudlog_t + 5.0:
         self.last_cloudlog_t = t
-        cloudlog.warning("Long mpc reset, solution_status: %s" % (
-                          self.solution_status))
+        cloudlog.warning(f"Long mpc reset, solution_status: {self.solution_status}")
       self.prev_lead_status = False
       self.reset()
 
--- /Users/braandon/openpilot/selfdrive/manager/build.py

+++ 

@@ -72,13 +72,13 @@

                   if any([err in line for err in [b'error: ', b'not found, needed by target']])]
         error_s = "\n".join(errors)
         add_file_handler(cloudlog)
-        cloudlog.error("scons build failed\n" + error_s)
+        cloudlog.error(f"scons build failed\n{error_s}")
 
         # Show TextWindow
         spinner.close()
         if not os.getenv("CI"):
           error_s = "\n \n".join(["\n".join(textwrap.wrap(e, 65)) for e in errors])
-          with TextWindow("openpilot failed to build\n \n" + error_s) as t:
+          with TextWindow(f"openpilot failed to build\n \n{error_s}") as t:
             t.wait_for_exit()
         exit(1)
     else:
--- /Users/braandon/openpilot/selfdrive/manager/process.py

+++ 

@@ -35,7 +35,7 @@

     # exec the process
     mod.main()
   except KeyboardInterrupt:
-    cloudlog.warning("child %s got SIGINT" % proc)
+    cloudlog.warning(f"child {proc} got SIGINT")
   except Exception:
     # can't install the crash handler because sys.excepthook doesn't play nice
     # with threads, so catch it here.
@@ -190,7 +190,7 @@

       return
 
     cwd = os.path.join(BASEDIR, self.cwd)
-    cloudlog.info("starting process %s" % self.name)
+    cloudlog.info(f"starting process {self.name}")
     self.proc = Process(name=self.name, target=nativelauncher, args=(self.cmdline, cwd))
     self.proc.start()
     self.watchdog_seen = False
@@ -210,7 +210,7 @@

 
   def prepare(self):
     if self.enabled:
-      cloudlog.info("preimporting %s" % self.module)
+      cloudlog.info(f"preimporting {self.module}")
       importlib.import_module(self.module)
 
   def start(self):
@@ -221,7 +221,7 @@

     if self.proc is not None:
       return
 
-    cloudlog.info("starting python %s" % self.module)
+    cloudlog.info(f"starting python {self.module}")
     self.proc = Process(name=self.name, target=launcher, args=(self.module,))
     self.proc.start()
     self.watchdog_seen = False
@@ -256,7 +256,7 @@

         # process is dead
         pass
 
-    cloudlog.info("starting daemon %s" % self.name)
+    cloudlog.info(f"starting daemon {self.name}")
     proc = subprocess.Popen(['python', '-m', self.module],  # pylint: disable=subprocess-popen-preexec-fn
                                stdin=open('/dev/null', 'r'),
                                stdout=open('/dev/null', 'w'),
--- /Users/braandon/openpilot/selfdrive/manager/manager.py

+++ 

@@ -205,7 +205,7 @@

 
     # Show last 3 lines of traceback
     error = traceback.format_exc(-3)
-    error = "Manager failed to start\n\n" + error
+    error = f"Manager failed to start\n\n{error}"
     with TextWindow(error) as t:
       t.wait_for_exit()
 
--- /Users/braandon/openpilot/selfdrive/loggerd/uploader.py

+++ 

@@ -147,7 +147,7 @@

 
   def do_upload(self, key, fn):
     try:
-      url_resp = self.api.get("v1.3/"+self.dongle_id+"/upload_url/", timeout=10, path=key, access_token=self.api.get_token())
+      url_resp = self.api.get(f"v1.3/{self.dongle_id}/upload_url/", timeout=10, path=key, access_token=self.api.get_token())
       if url_resp.status_code == 412:
         self.last_resp = url_resp
         return
@@ -158,7 +158,7 @@

       cloudlog.debug("upload_url v1.3 %s %s", url, str(headers))
 
       if fake_upload:
-        cloudlog.debug("*** WARNING, THIS IS A FAKE UPLOAD TO %s ***" % url)
+        cloudlog.debug(f"*** WARNING, THIS IS A FAKE UPLOAD TO {url} ***")
 
         class FakeResponse():
           def __init__(self):
--- /Users/braandon/openpilot/selfdrive/loggerd/deleter.py

+++ 

@@ -27,11 +27,11 @@

           continue
 
         try:
-          cloudlog.info("deleting %s" % delete_path)
+          cloudlog.info(f"deleting {delete_path}")
           shutil.rmtree(delete_path)
           break
         except OSError:
-          cloudlog.exception("issue deleting %s" % delete_path)
+          cloudlog.exception(f"issue deleting {delete_path}")
       exit_event.wait(.1)
     else:
       exit_event.wait(30)
--- /Users/braandon/openpilot/selfdrive/loggerd/tools/mark_unuploaded.py

+++ 

@@ -4,6 +4,6 @@

 from selfdrive.loggerd.uploader import UPLOAD_ATTR_NAME
 
 for fn in sys.argv[1:]:
-  print("unmarking %s" % fn)
+  print(f"unmarking {fn}")
   removexattr(fn, UPLOAD_ATTR_NAME)
 
--- /Users/braandon/openpilot/selfdrive/loggerd/tests/test_encoder.py

+++ 

@@ -107,7 +107,7 @@

         cmd = f"ffprobe -v error -count_frames -select_streams v:0 -show_entries stream=nb_read_frames \
                 -of default=nokey=1:noprint_wrappers=1 {file_path}"
         if TICI:
-          cmd = "LD_LIBRARY_PATH=/usr/local/lib " + cmd
+          cmd = f"LD_LIBRARY_PATH=/usr/local/lib {cmd}"
 
         expected_frames = fps * SEGMENT_LENGTH
         frame_tolerance = 1 if eon_dcam else 0
--- /Users/braandon/openpilot/selfdrive/loggerd/tests/loggerd_tests_common.py

+++ 

@@ -13,7 +13,7 @@

     except OSError:
       pass
 
-    lock_path = file_path + ".lock"
+    lock_path = f"{file_path}.lock"
     os.close(os.open(lock_path, os.O_CREAT | os.O_EXCL))
 
     chunks = 128
--- /Users/braandon/openpilot/selfdrive/modeld/visiontest.py

+++ 

@@ -62,7 +62,7 @@

       disable_model = 0
       temporal_model = 1
     else:
-      raise ValueError("Bad model name: {}".format(model))
+      raise ValueError(f"Bad model name: {model}")
 
     prevdir = os.getcwd()
     os.chdir(_visiond_dir)  # tmp hack to find kernels
--- /Users/braandon/openpilot/selfdrive/camerad/test/test_camerad.py

+++ 

@@ -54,7 +54,7 @@

           self.assertTrue(abs(dfid - 1) <= SKIP_FRAME_TOLERANCE, "%s frame id diff is %d" % (camera, dfid))
 
           dts = ct - last_ts[camera]
-          self.assertTrue(abs(dts - (1000/CAMERAS[camera])) < LAG_FRAME_TOLERANCE, "%s frame t(ms) diff is %f" % (camera, dts))
+          self.assertTrue(abs(dts - (1000/CAMERAS[camera])) < LAG_FRAME_TOLERANCE, f"{camera} frame t(ms) diff is {dts:f}")
 
           last_frame_id[camera] = sm[camera].frameId
           last_ts[camera] = ct
--- /Users/braandon/openpilot/selfdrive/debug/check_freq.py

+++ 

@@ -42,7 +42,7 @@

       for name in socket_names:
         dts = np.diff(rcv_times[name])
         mean = np.mean(dts)
-        print("%s: Freq %.2f Hz, Min %.2f%%, Max %.2f%%, valid " % (name, 1.0 / mean, np.min(dts) / mean * 100, np.max(dts) / mean * 100), all(valids[name]))
+        print(f"{name}: Freq {1.0 / mean:.2f} Hz, Min {np.min(dts) / mean * 100:.2f}%, Max {np.max(dts) / mean * 100:.2f}%, valid ", all(valids[name]))
 
       prev_print = t
 
--- /Users/braandon/openpilot/selfdrive/debug/get_fingerprint.py

+++ 

@@ -27,6 +27,6 @@

 
   fingerprint = ', '.join("%d: %d" % v for v in sorted(msgs.items()))
 
-  print("number of messages {0}:".format(len(msgs)))
-  print("fingerprint {0}".format(fingerprint))
+  print(f"number of messages {len(msgs)}:")
+  print(f"fingerprint {fingerprint}")
 
--- /Users/braandon/openpilot/selfdrive/debug/dump.py

+++ 

@@ -54,13 +54,13 @@

         elif args.dump_json:
           print(json.dumps(evt.to_dict()))
         elif values:
-          print("logMonotime = {}".format(evt.logMonoTime))
+          print(f"logMonotime = {evt.logMonoTime}")
           for value in values:
             if hasattr(evt, value[0]):
               item = evt
               for key in value:
                 item = getattr(item, key)
-              print("{} = {}".format(".".join(value), item))
+              print(f"{'.'.join(value)} = {item}")
           print("")
         else:
           try:
--- /Users/braandon/openpilot/selfdrive/debug/can_printer.py

+++ 

@@ -23,8 +23,8 @@

           msgs[y.address].append(y.dat)
 
     if sec_since_boot() - lp > 0.1:
-      dd = chr(27) + "[2J"
-      dd += "%5.2f\n" % (sec_since_boot() - start)
+      dd = f"{chr(27)}[2J"
+      dd += f"{sec_since_boot() - start:5.2f}\n"
       for k, v in sorted(zip(msgs.keys(), map(lambda x: binascii.hexlify(x[-1]), msgs.values()))):
         if max_msg is None or k < max_msg:
           dd += "%s(%6d) %s\n" % ("%04X(%4d)" % (k, k), len(msgs[k]), v.decode('ascii'))
--- /Users/braandon/openpilot/selfdrive/debug/live_cpu_and_temp.py

+++ 

@@ -22,7 +22,7 @@

   if len(proc.cmdline):
     name = proc.cmdline[0]
   if len(proc.exe):
-    name = proc.exe + " - " + name
+    name = f"{proc.exe} - {name}"
 
   return name
 
@@ -71,7 +71,7 @@

       total_times = total_times_new[:]
       busy_times = busy_times_new[:]
 
-      print("CPU %.2f%% - RAM: %.2f%% - Temp %.2fC" % (100. * mean(cores), last_mem, last_temp))
+      print(f"CPU {100.0 * mean(cores):.2f}% - RAM: {last_mem:.2f}% - Temp {last_temp:.2f}C")
 
       if args.cpu and prev_proclog is not None:
         procs = {}
Faulty result during conversion on /Users/braandon/openpilot/selfdrive/debug/cpu_usage_stat.py - skipping.
--- /Users/braandon/openpilot/selfdrive/debug/internal/power_monitor.py

+++ 

@@ -45,7 +45,7 @@

       capacity_average = average(capacity_average, capacity)
       bat_temp_average = average(bat_temp_average, bat_temp)
 
-      print("%.2f volts %12.2f ma %12.2f mW %8.2f%% battery %8.1f degC" % (voltage, current, power, capacity, bat_temp))
+      print(f"{voltage:.2f} volts {current:12.2f} ma {power:12.2f} mW {capacity:8.2f}% battery {bat_temp:8.1f} degC")
       time.sleep(0.1)
   finally:
     stop_time = datetime.now()
@@ -55,8 +55,8 @@

     power = power_average[0]
     capacity = capacity_average[0]
     bat_temp = bat_temp_average[0]
-    print("%.2f volts %12.2f ma %12.2f mW %8.2f%% battery %8.1f degC" % (voltage, current, power, capacity, bat_temp))
-    print("  {:.2f} Seconds     {} samples".format((stop_time-start_time).total_seconds(), voltage_average[1]))
+    print(f"{voltage:.2f} volts {current:12.2f} ma {power:12.2f} mW {capacity:8.2f}% battery {bat_temp:8.1f} degC")
+    print(f"  {(stop_time - start_time).total_seconds():.2f} Seconds     {voltage_average[1]} samples")
     print("----------------------------------------------------------------")
 
     # reenable charging
--- /Users/braandon/openpilot/selfdrive/debug/internal/design_lqr.py

+++ 

@@ -24,10 +24,10 @@

 sys = control.ss(A_cl, B, C, 0, dt)
 dc_gain = control.dcgain(sys)
 
-print(("self.A = np." + A.__repr__()).replace('\n', ''))
-print(("self.B = np." + B.__repr__()).replace('\n', ''))
-print(("self.C = np." + C.__repr__()).replace('\n', ''))
-print(("self.K = np." + K.__repr__()).replace('\n', ''))
-print(("self.L = np." + L.__repr__()).replace('\n', ''))
-print("self.dc_gain = " + str(dc_gain))
+print(f"self.A = np.{A.__repr__()}".replace('\n', ''))
+print(f"self.B = np.{B.__repr__()}".replace('\n', ''))
+print(f"self.C = np.{C.__repr__()}".replace('\n', ''))
+print(f"self.K = np.{K.__repr__()}".replace('\n', ''))
+print(f"self.L = np.{L.__repr__()}".replace('\n', ''))
+print(f"self.dc_gain = {str(dc_gain)}")
 
--- /Users/braandon/openpilot/selfdrive/debug/internal/sensor_test_bootloop.py

+++ 

@@ -42,13 +42,13 @@

   data['sensor-fail'] += 1
 
   timestr = str(int(time.time()))
-  with open('/tmp/dmesg-' + timestr + '.log', 'w') as dmesg_out:
+  with open(f"/tmp/dmesg-{timestr}.log", 'w') as dmesg_out:
     subprocess.call('dmesg', stdout=dmesg_out, shell=False)
-  with open("/tmp/logcat-" + timestr + '.log', 'w') as logcat_out:
+  with open(f"/tmp/logcat-{timestr}.log", 'w') as logcat_out:
     subprocess.call(['logcat', '-d'], stdout=logcat_out, shell=False)
 
-text += "Sensor pass history: " + str(data['sensor-pass']) + "\n"
-text += "Sensor fail history: " + str(data['sensor-fail']) + "\n"
+text += f"Sensor pass history: {str(data['sensor-pass'])}\n"
+text += f"Sensor fail history: {str(data['sensor-fail'])}\n"
 
 print(text)
 
--- /Users/braandon/openpilot/selfdrive/debug/internal/measure_steering_accuracy.py

+++ 

@@ -71,7 +71,7 @@

       cnt = 0
 
     if msg_cnt % 100 == 0:
-      print(chr(27) + "[2J")
+      print(f"{chr(27)}[2J")
       if cnt != 0:
         print("COLLECTING ...")
       else:
--- /Users/braandon/openpilot/selfdrive/athena/registration.py

+++ 

@@ -30,14 +30,14 @@

   # create a key for auth
   # your private key is kept on your device persist partition and never sent to our servers
   # do not erase your persist partition
-  if not os.path.isfile(PERSIST+"/comma/id_rsa.pub"):
+  if not os.path.isfile(f"{PERSIST}/comma/id_rsa.pub"):
     needs_registration = True
     cloudlog.warning("generating your personal RSA key")
-    mkdirs_exists_ok(PERSIST+"/comma")
-    assert os.system("openssl genrsa -out "+PERSIST+"/comma/id_rsa.tmp 2048") == 0
-    assert os.system("openssl rsa -in "+PERSIST+"/comma/id_rsa.tmp -pubout -out "+PERSIST+"/comma/id_rsa.tmp.pub") == 0
-    os.rename(PERSIST+"/comma/id_rsa.tmp", PERSIST+"/comma/id_rsa")
-    os.rename(PERSIST+"/comma/id_rsa.tmp.pub", PERSIST+"/comma/id_rsa.pub")
+    mkdirs_exists_ok(f"{PERSIST}/comma")
+    assert os.system(f"openssl genrsa -out {PERSIST}/comma/id_rsa.tmp 2048") == 0
+    assert os.system(f"openssl rsa -in {PERSIST}/comma/id_rsa.tmp -pubout -out {PERSIST}/comma/id_rsa.tmp.pub") == 0
+    os.rename(f"{PERSIST}/comma/id_rsa.tmp", f"{PERSIST}/comma/id_rsa")
+    os.rename(f"{PERSIST}/comma/id_rsa.tmp.pub", f"{PERSIST}/comma/id_rsa.pub")
 
   if needs_registration:
     if show_spinner:
@@ -45,7 +45,7 @@

       spinner.update("registering device")
 
     # Create registration token, in the future, this key will make JWTs directly
-    with open(PERSIST+"/comma/id_rsa.pub") as f1, open(PERSIST+"/comma/id_rsa") as f2:
+    with open(f"{PERSIST}/comma/id_rsa.pub") as f1, open(f"{PERSIST}/comma/id_rsa") as f2:
       public_key = f1.read()
       private_key = f2.read()
 
--- /Users/braandon/openpilot/selfdrive/athena/athenad.py

+++ 

@@ -285,7 +285,7 @@

     dongle_id = params.get("DongleId").decode('utf8')
     identity_token = Api(dongle_id).get_token()
     ws = create_connection(remote_ws_uri,
-                           cookie="jwt=" + identity_token,
+                           cookie=f"jwt={identity_token}",
                            enable_multithread=True)
 
     ssock, csock = socket.socketpair()
@@ -310,10 +310,10 @@

 
 @dispatcher.add_method
 def getPublicKey():
-  if not os.path.isfile(PERSIST + '/comma/id_rsa.pub'):
+  if not os.path.isfile(f"{PERSIST}/comma/id_rsa.pub"):
     return None
 
-  with open(PERSIST + '/comma/id_rsa.pub', 'r') as f:
+  with open(f"{PERSIST}/comma/id_rsa.pub", 'r') as f:
     return f.read()
 
 
@@ -542,7 +542,7 @@

   params = Params()
   dongle_id = params.get("DongleId", encoding='utf-8')
 
-  ws_uri = ATHENA_HOST + "/ws/v2/" + dongle_id
+  ws_uri = f"{ATHENA_HOST}/ws/v2/{dongle_id}"
   api = Api(dongle_id)
 
   conn_retries = 0
@@ -550,7 +550,7 @@

     try:
       cloudlog.event("athenad.main.connecting_ws", ws_uri=ws_uri)
       ws = create_connection(ws_uri,
-                             cookie="jwt=" + api.get_token(),
+                             cookie=f"jwt={api.get_token()}",
                              enable_multithread=True,
                              timeout=30.0)
       cloudlog.event("athenad.main.connected_ws", ws_uri=ws_uri)
--- /Users/braandon/openpilot/selfdrive/athena/tests/test_athenad_old.py

+++ 

@@ -46,7 +46,7 @@

     while 1:
       try:
         resp = requests.post(
-          "https://athena.comma.ai/" + params.get("DongleId", encoding="utf-8"),
+          f"https://athena.comma.ai/{params.get('DongleId', encoding='utf-8')}",
           headers={
             "Authorization": "JWT thisisnotajwt",
             "Content-Type": "application/json"
--- /Users/braandon/openpilot/common/ffi_wrapper.py

+++ 

@@ -15,7 +15,7 @@

   if libraries is None:
     libraries = []
 
-  cache = name + "_" + hashlib.sha1(c_code.encode('utf-8')).hexdigest()
+  cache = f"{name}_{hashlib.sha1(c_code.encode('utf-8')).hexdigest()}"
   try:
     os.mkdir(tmpdir)
   except OSError:
@@ -28,7 +28,7 @@

     try:
       mod = __import__(cache)
     except Exception:
-      print("cache miss {0}".format(cache))
+      print(f"cache miss {cache}")
       compile_code(cache, c_code, c_header, tmpdir, cflags, libraries)
       mod = __import__(cache)
   finally:
--- /Users/braandon/openpilot/common/realtime.py

+++ 

@@ -79,7 +79,7 @@

     remaining = self._next_frame_time - sec_since_boot()
     self._next_frame_time += self._interval
     if self._print_delay_threshold is not None and remaining < -self._print_delay_threshold:
-      print("%s lagging by %.2f ms" % (self._process_name, -remaining * 1000))
+      print(f"{self._process_name} lagging by {-remaining * 1000:.2f} ms")
       lagged = True
     self._frame += 1
     self._remaining = remaining
--- /Users/braandon/openpilot/common/timeout.py

+++ 

@@ -12,7 +12,7 @@

   """
   def __init__(self, seconds, error_msg=None):
     if error_msg is None:
-      error_msg = 'Timed out after {} seconds'.format(seconds)
+      error_msg = f'Timed out after {seconds} seconds'
     self.seconds = seconds
     self.error_msg = error_msg
 
--- /Users/braandon/openpilot/common/profiler.py

+++ 

@@ -42,5 +42,5 @@

         print("%30s: %9.2f  avg: %7.2f  percent: %3.0f   IGNORED" % (n, ms*1000.0, ms*1000.0/self.iter, ms/self.tot*100))
       else:
         print("%30s: %9.2f  avg: %7.2f  percent: %3.0f" % (n, ms*1000.0, ms*1000.0/self.iter, ms/self.tot*100))
-    print("Iter clock: %2.6f   TOTAL: %2.2f" % (self.tot/self.iter, self.tot))
+    print(f"Iter clock: {self.tot / self.iter:2.6f}   TOTAL: {self.tot:2.2f}")
 
--- /Users/braandon/openpilot/common/file_helpers.py

+++ 

@@ -35,7 +35,7 @@

   if len(parts) > 1 and parts[1] == "scratch":
     return "/scratch/tmp"
   elif len(parts) > 2 and parts[2] == "runner":
-    return "/{}/runner/tmp".format(parts[1])
+    return f"/{parts[1]}/runner/tmp"
   return "/tmp"
 
 
--- /Users/braandon/openpilot/common/tests/test_file_helpers.py

+++ 

@@ -8,7 +8,7 @@

 
 class TestFileHelpers(unittest.TestCase):
   def run_atomic_write_func(self, atomic_write_func):
-    path = "/tmp/tmp{}".format(uuid4())
+    path = f"/tmp/tmp{uuid4()}"
     with atomic_write_func(path) as f:
       f.write("test")
 
--- /Users/braandon/openpilot/common/api/__init__.py

+++ 

@@ -10,7 +10,7 @@

 class Api():
   def __init__(self, dongle_id):
     self.dongle_id = dongle_id
-    with open(PERSIST+'/comma/id_rsa') as f:
+    with open(f"{PERSIST}/comma/id_rsa") as f:
       self.private_key = f.read()
 
   def get(self, *args, **kwargs):
@@ -39,9 +39,9 @@

 def api_get(endpoint, method='GET', timeout=None, access_token=None, **params):
   headers = {}
   if access_token is not None:
-    headers['Authorization'] = "JWT "+access_token
+    headers['Authorization'] = f"JWT {access_token}"
 
-  headers['User-Agent'] = "openpilot-" + version
+  headers['User-Agent'] = f"openpilot-{version}"
 
-  return requests.request(method, API_HOST + "/" + endpoint, timeout=timeout, headers=headers, params=params)
+  return requests.request(method, f"{API_HOST}/{endpoint}", timeout=timeout, headers=headers, params=params)
 
--- /Users/braandon/openpilot/cereal/messaging/demo.py

+++ 

@@ -26,5 +26,5 @@

       assert(i == ii)
 
   dt = time.time() - t
-  print("%.1f msg/s" % (MSGS / dt))
+  print(f"{MSGS / dt:.1f} msg/s")
 
--- /Users/braandon/openpilot/cereal/site_scons/site_tools/cython.py

+++ 

@@ -17,8 +17,8 @@

   matches += pyx_import_re.findall(contents)
 
   # Modules can be either .pxd or .pyx files
-  files = [m.replace('.', '/') + '.pxd' for m in matches]
-  files += [m.replace('.', '/') + '.pyx' for m in matches]
+  files = [f"{m.replace('.', '/')}.pxd" for m in matches]
+  files += [f"{m.replace('.', '/')}.pyx" for m in matches]
 
   # cdef extern from <file>
   files += cdef_import_re.findall(contents)
--- /Users/braandon/openpilot/laika_repo/laika/ephemeris.py

+++ 

@@ -10,7 +10,7 @@

 def read4(f, rinex_ver):
   line = f.readline()[:-1]
   if rinex_ver == 2:
-    line = ' ' + line  # Shift 1 char to the right
+    line = f" {line}"  # Shift 1 char to the right
   line = line.replace('D', 'E')  # Handle bizarro float format
   return float(line[4:23]), float(line[23:42]), float(line[42:61]), float(line[61:80])
 
@@ -286,7 +286,7 @@

         # In old SP3 files vehicle ID doesn't contain constellation
         # identifier. We assume that constellation is GPS when missing.
         if prn[0] == '0':
-          prn = 'G' + prn[1:]
+          prn = f"G{prn[1:]}"
         if get_constellation(prn) not in SUPPORTED_CONSTELLATIONS:
           continue
         if prn not in data:
@@ -370,9 +370,9 @@

       # 2000 year is in RINEX file as 0, but Python requires two digit year: 00
       epoch_str = line[3:20]
       if epoch_str[0] == ' ':
-        epoch_str = '0' + epoch_str[1:]
+        epoch_str = f"0{epoch_str[1:]}"
       epoch = GPSTime.from_datetime(datetime.strptime(epoch_str, "%y %m %d %H %M %S"))
-      line = ' ' + line  # Shift 1 char to the right
+      line = f" {line}"  # Shift 1 char to the right
 
     line = line.replace('D', 'E')  # Handle bizarro float format
     e = {'epoch': epoch, 'prn': prn}
@@ -422,7 +422,7 @@

     elif rinex_ver == 2:
       prn = 'R%02i' % int(line[0:2])
       epoch = GPSTime.from_datetime(datetime.strptime(line[3:20], "%y %m %d %H %M %S"))
-      line = ' ' + line  # Shift 1 char to the right
+      line = f" {line}"  # Shift 1 char to the right
 
     line = line.replace('D', 'E')  # Handle bizarro float format
     e = {'epoch': epoch, 'prn': prn}
--- /Users/braandon/openpilot/laika_repo/laika/downloader.py

+++ 

@@ -46,11 +46,11 @@

     ftp = ftplib.FTP(domain, timeout=10)
     ftp.login()
   except (OSError, ftplib.error_perm):
-    raise IOError("Could not connect/auth to: " + domain)
+    raise IOError(f"Could not connect/auth to: {domain}")
   try:
     ftp.cwd(parsed.path)
   except ftplib.error_perm:
-    raise IOError("Permission failure with folder: " + url)
+    raise IOError(f"Permission failure with folder: {url}")
   return ftp
 
 @retryable
@@ -59,7 +59,7 @@

     ftp = ftp_connect(url)
     return ftp.nlst()
   except ftplib.error_perm:
-    raise IOError("Permission failure listing folder: " + url)
+    raise IOError(f"Permission failure listing folder: {url}")
 
 def ftp_download_files(url_base, folder_path, cacheDir, filenames, compression='', overwrite=False):
   """
@@ -81,11 +81,11 @@

       if not os.path.exists(folder_path_abs):
         os.makedirs(folder_path_abs)
       try:
-        ftp.retrbinary('RETR ' + filename_zipped, open(filepath_zipped, 'wb').write)
+        ftp.retrbinary(f"RETR {filename_zipped}", open(filepath_zipped, 'wb').write)
       except (ftplib.error_perm):
-        raise IOError("Could not download file from: " + url_base + folder_path + filename_zipped)
+        raise IOError(f"Could not download file from: {url_base}{folder_path}{filename_zipped}")
       except (socket.timeout):
-        raise IOError("Read timed out from: " + url_base + folder_path + filename_zipped)
+        raise IOError(f"Read timed out from: {url_base}{folder_path}{filename_zipped}")
       filepaths.append(str(hatanaka.decompress_on_disk(filepath_zipped)))
     else:
       filepaths.append(filepath)
@@ -96,8 +96,8 @@

   if 'nasa.gov/' not in url:
     netrc_path = None
     f = None
-  elif os.path.isfile(dir_path + '/.netrc'):
-    netrc_path = dir_path + '/.netrc'
+  elif os.path.isfile(f"{dir_path}/.netrc"):
+    netrc_path = f"{dir_path}/.netrc"
     f = None
   else:
     try:
@@ -131,7 +131,7 @@

     f.close()
 
   if response != 200:
-    raise IOError('HTTPS error ' + str(response))
+    raise IOError(f"HTTPS error {str(response)}")
   return buf.getvalue()
 
 
@@ -152,7 +152,7 @@

 @retryable
 def download_file(url_base, folder_path, filename_zipped):
   url = url_base + folder_path + filename_zipped
-  print('Downloading ' + url)
+  print(f"Downloading {url}")
   if 'https' in url:
     data_zipped = https_download_file(url)
   elif 'ftp':
@@ -167,7 +167,7 @@

   filename_zipped = filename + compression
 
   filepath = str(hatanaka.get_decompressed_path(os.path.join(folder_path_abs, filename)))
-  filepath_attempt = filepath + '.attempt_time'
+  filepath_attempt = f"{filepath}.attempt_time"
   filepath_zipped = os.path.join(folder_path_abs, filename_zipped)
 
   if os.path.exists(filepath_attempt):
@@ -184,11 +184,11 @@

       data_zipped = download_file(url_base, folder_path, filename_zipped)
     except (IOError, pycurl.error, socket.timeout):
       unix_time = time.time()
-      if not os.path.exists(cacheDir + 'tmp/'):
-        os.makedirs(cacheDir + '/tmp')
-      with tempfile.NamedTemporaryFile(delete=False, dir=cacheDir+'tmp/') as fout:
+      if not os.path.exists(f"{cacheDir}tmp/"):
+        os.makedirs(f"{cacheDir}/tmp")
+      with tempfile.NamedTemporaryFile(delete=False, dir=f"{cacheDir}tmp/") as fout:
         fout.write(str.encode(str(unix_time)))
-      os.replace(fout.name, filepath + '.attempt_time')
+      os.replace(fout.name, f"{filepath}.attempt_time")
       raise IOError(f"Could not download {folder_path + filename_zipped} from {url_base} ")
 
 
@@ -207,7 +207,7 @@

         'https://github.com/commaai/gnss-data/raw/master/gnss/data/daily/',
         'https://cddis.nasa.gov/archive/gnss/data/daily/',
       )
-      cache_subdir = cache_dir + 'daily_nav/'
+      cache_subdir = f"{cache_dir}daily_nav/"
       if constellation =='GPS':
         filename = t.strftime("brdc%j0.%yn")
         folder_path = t.strftime('%Y/%j/%yn/')
@@ -218,7 +218,7 @@

       return download_and_cache_file(url_bases, folder_path, cache_subdir, filename, compression=compression)
     else:
       url_base = 'https://cddis.nasa.gov/archive/gnss/data/hourly/'
-      cache_subdir = cache_dir + 'hourly_nav/'
+      cache_subdir = f"{cache_dir}hourly_nav/"
       if constellation =='GPS':
         filename = t.strftime("hour%j0.%yn")
         folder_path = t.strftime('%Y/%j/')
@@ -229,7 +229,7 @@

 
 
 def download_orbits(time, cache_dir):
-  cache_subdir = cache_dir + 'cddis_products/'
+  cache_subdir = f"{cache_dir}cddis_products/"
   url_bases = (
     'https://github.com/commaai/gnss-data/raw/master/gnss/products/',
     'https://cddis.nasa.gov/archive/gnss/products/',
@@ -279,7 +279,7 @@

 
 
 def download_orbits_russia(time, cache_dir):
-  cache_subdir = cache_dir + 'russian_products/'
+  cache_subdir = f"{cache_dir}russian_products/"
   url_bases = (
     'https://github.com/commaai/gnss-data-alt/raw/master/MCC/PRODUCTS/',
     'ftp://ftp.glonass-iac.ru/MCC/PRODUCTS/',
@@ -311,7 +311,7 @@

 
 
 def download_ionex(time, cache_dir):
-  cache_subdir = cache_dir + 'ionex/'
+  cache_subdir = f"{cache_dir}ionex/"
   t = time.as_datetime()
   url_bases = (
     'https://github.com/commaai/gnss-data/raw/master/gnss/products/ionex/',
@@ -330,7 +330,7 @@

 
 
 def download_dcb(time, cache_dir):
-  cache_subdir = cache_dir + 'dcb/'
+  cache_subdir = f"{cache_dir}dcb/"
   # seem to be a lot of data missing, so try many days
   for time in [time - i*SECS_IN_DAY for i in range(14)]:
     try:
@@ -350,7 +350,7 @@

 
 
 def download_cors_coords(cache_dir):
-  cache_subdir = cache_dir + 'cors_coord/'
+  cache_subdir = f"{cache_dir}cors_coord/"
   url_bases = (
     'ftp://geodesy.noaa.gov/cors/coord/coord_14/',
     'ftp://alt.ngs.noaa.gov/cors/coord/coord_14/'
@@ -362,9 +362,9 @@

 
 
 def download_cors_station(time, station_name, cache_dir):
-  cache_subdir = cache_dir + 'cors_obs/'
+  cache_subdir = f"{cache_dir}cors_obs/"
   t = time.as_datetime()
-  folder_path = t.strftime('%Y/%j/') + station_name + '/'
+  folder_path = f"{t.strftime('%Y/%j/') + station_name}/"
   filename = station_name + t.strftime("%j0.%yd")
   url_bases = (
     'ftp://geodesy.noaa.gov/cors/rinex/',
--- /Users/braandon/openpilot/laika_repo/laika/gps_time.py

+++ 

@@ -147,7 +147,7 @@

     return int(self.tow/(24*3600))
 
   def __str__(self):
-    return "week: " + str(self.week) + "  tow: " + str(self.tow)
+    return f"week: {str(self.week)}  tow: {str(self.tow)}"
 
 
 class TimeSyncer(object):
--- /Users/braandon/openpilot/laika_repo/laika/rinex_file.py

+++ 

@@ -62,17 +62,17 @@

     self.version = float(version_line[0:9])
     if (self.version > 2.11):
       raise ValueError(
-        "RINEX file versions > 2.11 not supported (file version %f)" % self.version)
+        f"RINEX file versions > 2.11 not supported (file version {self.version:f})")
 
     self.filetype = version_line[20]
     if self.filetype not in "ONGM":  # Check valid file type
-      raise ValueError("RINEX file type '%s' not supported" % self.filetype)
+      raise ValueError(f"RINEX file type '{self.filetype}' not supported")
     if self.filetype != 'O':
       raise ValueError("Only 'OBSERVATION DATA' RINEX files are currently supported")
 
     self.gnss = version_line[40]
     if self.gnss not in " GRSEM":  # Check valid satellite system
-      raise ValueError("Satellite system '%s' not supported" % self.filetype)
+      raise ValueError(f"Satellite system '{self.filetype}' not supported")
     if self.gnss == ' ':
       self.gnss = 'G'
     if self.gnss != 'G':
@@ -86,7 +86,7 @@

       if label == "END OF HEADER":
         break
       if label == "COMMENT":
-        self.comment += line[:60] + '\n'
+        self.comment += f"{line[:60]}\n"
       if label == "MARKER NAME":
         self.marker_name = line[:60].rstrip()
         if self.marker_name == '':
--- /Users/braandon/openpilot/laika_repo/laika/dcb.py

+++ 

@@ -71,7 +71,7 @@

     prn = line_components[2]
     if get_constellation(prn) not in SUPPORTED_CONSTELLATIONS:
       continue
-    dcb_type = line_components[3] + '_' + line_components[4]
+    dcb_type = f"{line_components[3]}_{line_components[4]}"
     epoch = GPSTime.from_datetime(datetime.strptime(line_components[5], '%Y:%j:%f')) + 12*SECS_IN_HR
     if prn not in dcbs_dict:
       dcbs_dict[prn] = {}
--- /Users/braandon/openpilot/laika_repo/laika/astro_dog.py

+++ 

@@ -65,7 +65,7 @@

     if self.cached_ionex is not None and self.cached_ionex.valid(time):
       return self.cached_ionex
     elif self.auto_update:
-      raise RuntimeError("Pulled ionex, but still can't get valid for time " + str(time))
+      raise RuntimeError(f"Pulled ionex, but still can't get valid for time {str(time)}")
     else:
       return None
 
@@ -178,7 +178,7 @@

     if self.cached_dgps is not None and self.cached_dgps.valid(time, recv_pos):
       return self.cached_dgps
     elif self.auto_update:
-      raise RuntimeError("Pulled dgps, but still can't get valid for time " + str(time))
+      raise RuntimeError(f"Pulled dgps, but still can't get valid for time {str(time)}")
     else:
       return None
 
--- /Users/braandon/openpilot/laika_repo/laika/dgps.py

+++ 

@@ -54,7 +54,7 @@

 
 
 def get_closest_station_names(pos, k=5, max_distance=100000, cache_dir='/tmp/gnss/'):
-  cors_station_positions_path = cache_dir + 'cors_coord/cors_station_positions'
+  cors_station_positions_path = f"{cache_dir}cors_coord/cors_station_positions"
   download_and_parse_station_postions(cors_station_positions_path, cache_dir)
   cors_station_positions_file = open(cors_station_positions_path, 'rb')
   cors_station_positions_dict = np.load(cors_station_positions_file, allow_pickle=True).item()  # pylint: disable=unexpected-keyword-arg
@@ -69,7 +69,7 @@

 
 
 def get_station_position(station_id, cache_dir='/tmp/gnss/', time=GPSTime.from_datetime(datetime.utcnow())):
-  cors_station_positions_path = cache_dir + 'cors_coord/cors_station_positions'
+  cors_station_positions_path = f"{cache_dir}cors_coord/cors_station_positions"
   download_and_parse_station_postions(cors_station_positions_path, cache_dir)
   cors_station_positions_file = open(cors_station_positions_path, 'rb')
   cors_station_positions_dict = np.load(cors_station_positions_file, allow_pickle=True).item()  # pylint: disable=unexpected-keyword-arg
--- /Users/braandon/openpilot/laika_repo/laika/helpers.py

+++ 

@@ -116,7 +116,7 @@

   if identifier in RINEX_CONSTELLATION_IDENTIFIERS:
     return RINEX_CONSTELLATION_IDENTIFIERS[identifier]
   else:
-    warnings.warn("Unknown constellation for PRN %s" % prn)
+    warnings.warn(f"Unknown constellation for PRN {prn}")
     return None
 
 
@@ -187,16 +187,16 @@

       return start + index_in_range
     else:
       constellation_offset += range_width
-  raise NotImplementedError("NMEA ID not found for PRN %s" % prn)
+  raise NotImplementedError(f"NMEA ID not found for PRN {prn}")
 
 
 def rinex3_obs_from_rinex2_obs(observable):
   if observable == 'P2':
     return 'C2P'
   if len(observable) == 2:
-    return observable + 'C'
+    return f"{observable}C"
   else:
-      raise NotImplementedError("Don't know this: " + observable)
+      raise NotImplementedError(f"Don't know this: {observable}")
 
 
 class TimeRangeHolder:
--- /Users/braandon/openpilot/laika_repo/examples/kalman/ekf_sym.py

+++ 

@@ -132,10 +132,10 @@

     extra_header += "\nconst static double MAHA_THRESH_%d = %f;" % (kind, maha_thresh)
     extra_header += "\nvoid update_%d(double *, double *, double *, double *, double *);" % kind
 
-  code += "\n" + extra_header
-  code += "\n" + open(os.path.join(EXTERNAL_PATH, "ekf_c.c")).read()
-  code += "\n" + extra_post
-  header += "\n" + extra_header
+  code += f"\n{extra_header}"
+  code += f"\n{open(os.path.join(EXTERNAL_PATH, 'ekf_c.c')).read()}"
+  code += f"\n{extra_post}"
+  header += f"\n{extra_header}"
   compile_code(name, code, header, EXTERNAL_PATH)
 
 class EKF_sym(object):
@@ -186,20 +186,20 @@

 
     # wrap all the sympy functions
     def wrap_1lists(name):
-      func = eval("lib.%s" % name, {"lib":lib})
+      func = eval(f"lib.{name}", {"lib":lib})
       def ret(lst1, out):
         func(ffi.cast("double *", lst1.ctypes.data),
           ffi.cast("double *", out.ctypes.data))
       return ret
     def wrap_2lists(name):
-      func = eval("lib.%s" % name, {"lib":lib})
+      func = eval(f"lib.{name}", {"lib":lib})
       def ret(lst1, lst2, out):
         func(ffi.cast("double *", lst1.ctypes.data),
           ffi.cast("double *", lst2.ctypes.data),
           ffi.cast("double *", out.ctypes.data))
       return ret
     def wrap_1list_1float(name):
-      func = eval("lib.%s" % name, {"lib":lib})
+      func = eval(f"lib.{name}", {"lib":lib})
       def ret(lst1, fl, out):
         func(ffi.cast("double *", lst1.ctypes.data),
           ffi.cast("double", fl),
@@ -230,7 +230,7 @@

 
     # wrap the C++ update function
     def fun_wrapper(f, kind):
-      f = eval("lib.%s" % f, {"lib": lib})
+      f = eval(f"lib.{f}", {"lib": lib})
       def _update_inner_blas(x, P, z, R, extra_args):
         f(ffi.cast("double *", x.ctypes.data),
           ffi.cast("double *", P.ctypes.data),
@@ -340,7 +340,7 @@

     # rewind
     if t < self.filter_time:
       if len(self.rewind_t) == 0 or t < self.rewind_t[0] or t < self.rewind_t[-1] -1.0:
-        print("observation too old at %.3f with filter at %.3f, ignoring" % (t, self.filter_time))
+        print(f"observation too old at {t:.3f} with filter at {self.filter_time:.3f}, ignoring")
         return None
       rewound = self.rewind(t)
     else:
--- /Users/braandon/openpilot/laika_repo/examples/kalman/ffi_wrapper.py

+++ 

@@ -7,7 +7,7 @@

 TMPDIR = "/tmp/ccache"
 
 def ffi_wrap(name, c_code, c_header, tmpdir=TMPDIR, cflags="", libraries=[]):
-  cache = name + "_" + hashlib.sha1(c_code).hexdigest()
+  cache = f"{name}_{hashlib.sha1(c_code).hexdigest()}"
   try:
     os.mkdir(tmpdir)
   except OSError:
--- /Users/braandon/openpilot/site_scons/site_tools/cython.py

+++ 

@@ -17,8 +17,8 @@

   matches += pyx_import_re.findall(contents)
 
   # Modules can be either .pxd or .pyx files
-  files = [m.replace('.', '/') + '.pxd' for m in matches]
-  files += [m.replace('.', '/') + '.pyx' for m in matches]
+  files = [f"{m.replace('.', '/')}.pxd" for m in matches]
+  files += [f"{m.replace('.', '/')}.pyx" for m in matches]
 
   # cdef extern from <file>
   files += cdef_import_re.findall(contents)

Flynt run has finished. Stats:

Execution time:                            8.286s
Files modified:                            131
Character count reduction:                 1466 (0.06%)

Per expression type:
Old style (`%`) expressions attempted:     132/262 (50.4%)
`.format(...)` calls attempted:            105/105 (100.0%)
String concatenations attempted:           226/233 (97.0%)
F-string expressions created:              441
Out of all attempted transforms, 132 resulted in errors.
To find out specific error messages, use --verbose flag.

_-_._-_._-_._-_._-_._-_._-_._-_._-_._-_._-_._-_._-_._-_._-_._-_._-_._-_._-_._-_._-_._-_._-_._-_._-_.
Please run your tests before committing. Did flynt get a perfect conversion? give it a star at: 
~ https://github.com/ikamensh/flynt ~
Thank you for using flynt. Upgrade more projects and recommend it to your colleagues!

